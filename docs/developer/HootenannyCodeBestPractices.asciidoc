
== Code Best Practices

=== Core

==== General

Many of these come directly from https://sonarcloud.io/dashboard?id=hoot[Sonar] recommendations.

* Keep as much implementation out of header files as possible. The implementations of simple 
getters/setters are ok in a header file.
* Use forward declarations where possible to mimimize build dependencies.
* Similar class methods/variables should be grouped together in the header file with 
constructors/destructors being toward the top.
* Per class member access type, list member variables before member methods.
* Place getters/setters at the end of the public documentation in the header file.
* Group header includes by type. e.g. hoot includes together, Qt includes together, etc.
* Header includes should be alphabetized.
* Keep as much logic out of classes inheriting `BaseCommand` as possible. Create a new class to hold
logic needed to be executed by the command.
* Use default constructors and destructors where applicable.
* Use `std::make_shared` to create shared pointers when possible.
* Pass variables to methods as const references when possible.
* Make methods const when possible.
* Use appropriately descriptive class names.
* Keep classes focused on a single primary functionality.
* Public class member variables are generally discouraged, with the exception of `const` or 
`struct` member variables.
* Initialize class member variables in the constructor inline when possible.
* Favor constructors with signatures that force the client of a class to set it up properly vs many 
getter methods.
* Use interface inheritance with a focus on simple, skinny interface definitions.
* Avoid "magic" strings. Tie strings whose values may change to a class member variable or 
configuration option when possible.

==== Hootenanny Specific

* Make use of configuration options via the `Configurable` interface to keep functionality adapatable 
to a broad range of data inputs.
* Favor the visitor pattern via classes ineriting `ElementVisitor` for map data processing. Use 
`OsmMapOperation` only when the data processor needs a copy of a complete map to performs its logic.
* Use classes inheriting `ElementCriterion` to identify data based on its properties.
* Use streaming I/O whereever possible to avoid loading large maps into memory all at once.
* Place experimental code into the `hoot-rnd` library. This code is expected to be at a lower TRL 
than code in `hoot-core`, and we can be a little lenient on test coverage.
* Make use of the `ApiEntityInfo` interface to appropriately describe map operators (classes 
inheriting `OsmMapOperation`, `ElementVisitor`, `ElementCriterion`, etc.).
* Make use of the `OperationStatus` interface and the `Progress` class to appropriately report 
progress for map operators (classes inheriting `OsmMapOperation`, `ElementVisitor`, 
`ElementCriterion`, etc.).
* Make use of the `FilteredByGeometryTypeCriteria` interface to properly describe the feature 
geometry types a map operator (classes inheriting `OsmMapOperation`, `ElementVisitor`, 
`ElementCriterion`, etc.) operates on.
* Make use of object pools when objects are created in very large numbers (> 10^6) e.g. create 
`Node` with `Node::newSp`. For element objects, this generally is done in reader classes.
* See the "General Test Writing Guidelines" section in the 
https://github.com/ngageoint/hootenanny/blob/master/docs/developer/HootenannyTests.asciidoc[testing document] 
for some test writing tips.

