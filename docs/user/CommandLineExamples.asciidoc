
[[CommandLineExamples]]
== Command Line Examples

See the User Guide for more details on command usage.

=== Basic

==== Display available commands:

-----
    hoot
-----

==== Display help for a command:

-----
    hoot help conflate
-----

==== Conflation

===== Conflate two maps into a single map using the first map as a reference (Reference Conflation):

-----
    hoot conflate input1.osm input2.osm output.osm
-----

===== Conflate two maps into a single map while averaging features (Average Conflation):

-----
    hoot conflate -C AverageConflation.conf input1.osm input2.osm output.osm
-----

===== Conflate, adding data from the second map to output that does not conflict with data in the first map (Differential Conflation):

-----
    hoot conflate -C DifferentialConflation.conf input1.osm input2.osm output.osm --differential
-----

===== Conflate only buildings:

-----
    hoot conflate -D match.creators="hoot::BuildingMatchCreator" -D merger.creators="hoot::BuildingMergerCreator" \ 
      input1.osm input2.osm output.osm
-----

===== Conflate only restaurant buildings:

-----
    hoot conflate -D match.creators="hoot::BuildingMatchCreator" -D merger.creators="hoot::BuildingMergerCreator" \ 
      -D conflate.tag.filter="{ \"must\": [ { \"tag\": \"amenity=restaurant\" } ] }" \
      input1.osm input2.osm output.osm
-----

===== Conflate only restaurant buildings with "Subway" in the name:

-----
    hoot conflate -D match.creators="hoot::BuildingMatchCreator" -D merger.creators="hoot::BuildingMergerCreator" \ 
      -D conflate.tag.filter="{ \"must\": [ { \"tag\": \"amenity=restaurant\" } ] }" \
      -D conflate.pre.ops="hoot::TagCriterion" -D tag.criterion.kvps="name;Subway" \
      input1.osm input2.osm output.osm
-----

===== Conflate specifying a JSON feature filter as a file (see the User Guide Feature Filtering section for more filter examples):

-----
    hoot conflate -D conflate.tag.filter=myFilter.json input1.osm input2.osm output.osm
-----

===== Conflate over a bounding box (not supported by all input formats):

-----
    # rectangular bounding box
    hoot conflate -D bounds="-71.4698,42.4866,-71.4657,42.4902" input1.osm input2.osm output.osm

    # non-rectangular polygon bounds
    hoot conflate -D bounds="-71.4745,42.4841;-71.4669,42.4918;-71.4619,42.4839;-71.4745,42.4841" input1.osm \
      input2.osm output.osm
-----

==== Applying Changes

===== Derive a changeset between two maps and write the result back to a Rails Port instance:

-----
    hoot changeset-derive input1.osm input2.osm changeset.osc
    hoot changeset-apply changeset.osc http://railsPortUrl --stats --progress
-----

===== Create a changeset that replaces all features in one dataset with features from another dataset within a specified bounding box:

-----
    hoot changeset-derive -D changeset.user.id=1 -D bounds="-71.4698,42.4866,-71.4657,42.4902" \
      input1.osm input2.osm output.osc --replacement
-----

===== Create a changeset that completely replaces features with those from another dataset within a specified non-rectangular bounds:

-----
    hoot changeset-derive -D changeset.user.id=1 \
      -D bounds="-71.4745,42.4841;-71.4669,42.4918;-71.4619,42.4839;-71.4745,42.4841" \
      input1.osm input2.osm output.osc --replacement
-----

==== MetaInfo

===== List all configuration option names:

-----
    hoot info --config-options
-----

===== List all supported input data formats:

-----
    hoot info --formats --input
-----

===== List all supported output data formats:

-----
    hoot info --formats --output
-----

===== List all available cleaning operations:

-----
    hoot info --cleaning-operations
-----

==== Data Transformation

===== Combine multiple OSM files into a single file:

-----
    hoot convert input1.osm input2.osm output.osm
-----

===== Combine multiple OSM files into a single file within a bounding box:

-----
    hoot convert -D bounds="-71.4698,42.4866,-71.4657,42.4902" input1.osm input2.osm output.osm
-----

===== Combine multiple OSM files into a single file within a polygon area:

-----
    hoot convert -D bounds="-71.4745,42.4841;-71.4669,42.4918;-71.4619,42.4839;-71.4745,42.4841" \
      input1.osm input2.osm output.osm
-----

===== Convert a geonames file to an OSM file:

-----
    hoot convert input.geonames output.osm
-----

===== Convert an OSM file to a file geodatabase and apply an OGR schema translation:

-----
    hoot convert -D schema.translation.script=MyTranslation.js input.osm output.gdb
-----

===== Convert an OSM API database to a file geodatabase and apply an OGR schema translation:

-----
    hoot convert -D schema.translation.script=MyTranslation.js \
      PG:"dbname='mydb' host='myhost' port='5432' user='myuser' password='mypass'" output.gdb
-----

===== Convert an OSM file to a shape file while specifying export columns:

-----
    hoot convert -D shape.file.writer.cols="highway,surface,name,alt_name,oneway,bridge" input.osm output.shp
-----

===== Convert multiple shape files to an OSM file with schema translation:

-----
    hoot convert -D schema.translation.script=MyTranslation.js input1.shp input2.shp output.osm
-----

===== Convert roads, bridges, overpasses and tunnels from a file geodatabase into a single .osm file with schema translation:

-----
    hoot convert -D schema.translation.script=MyTranslation.js \
      input.gdb;ROAD_L input.gdb;BRIDGE_OVERPASS_L input.gdb;TUNNEL_L output.osm
-----

===== Convert and translate a shape file that is stored inside of a zip file:

-----
    hoot convert -D schema.translation.script=MyTranslation.js /vsizip//gis-data/input.zip/tds/LAP030.shp output.osm
-----

==== Utilities

===== Clean erroneous data from two maps:

-----
    hoot clean input.osm output.osm
-----

===== Clean erroneous data from two maps using Hooteanny's default cleaning operations plus JOSM's cleaning capabilities:

-----
    hoot clean -D map.cleaner.transforms++=hoot::JosmMapCleaner input.osm output.osm
-----

===== Clean erroneous data from two maps using Hooteanny's default cleaning operations plus a subset of JOSM's cleaning capabilities via exclusion:

-----
    hoot clean -D map.cleaner.transforms++=hoot::JosmMapCleaner \
      -D josm.validators.exclude="UntaggedWay;DuplicatedWayNodes" input.osm output.osm
-----

===== Clean erroneous data from two maps using Hooteanny's default cleaning operations plus a subset of JOSM's cleaning capabilities via inclusion:

-----
    hoot clean -D map.cleaner.transforms++=hoot::JosmMapCleaner \
      -D josm.validators.include="UntaggedWay;DuplicatedWayNodes" input.osm output.osm
-----

===== Run JOSM cleaning only on a map:

-----
    hoot convert -D convert.ops=hoot::JosmMapCleaner input.osm output.osm
-----

===== Run JOSM validation on a map:

-----
    hoot validate input.osm output.osm
-----

===== List the available JOSM validators:

-----
    hoot validate --available-validators
-----

===== Prepend a cleaning operation to the existing set of cleaning operations:

-----
    hoot clean -D map.cleaner.transforms++=hoot::MyCleaningOp input.osm output.osm
-----

===== Append a cleaning operation to the existing set of cleaning operations:

-----
    hoot clean -D map.cleaner.transforms+=hoot::MyCleaningOp input.osm output.osm
-----

===== Remove a cleaning operation from the existing set of cleaning operations:

-----
    hoot clean -D map.cleaner.transforms-=hoot::NoInformationElementRemover input.osm output.osm
-----

===== Crop a map:

-----
    hoot crop input.osm output.osm "-77.0551,38.8845,-77.0281,38.9031"
-----

===== Bring two maps closer in alignment:

-----
    hoot align input1.osm input2.osm output.osm
-----

===== Display the geospatial extent of a map:

-----
    hoot extent input.osm
-----

===== Determine if a map is sorted to the OSM standard:

-----
    hoot is-sorted input.osm
-----

===== Sort a map to the OSM standard in memory:

-----
    hoot sort input.osm output.osm
-----

===== Tag features with a conflate matcher capable of matching them (useful in debugging):

-----
    hoot convert -D convert.ops="hoot::ConflatableCriteriaVisitor" input.osm output.osm
-----

===== Snap unconnected roads in one dataset back to neighboring roads in another dataset:

-----
    hoot convert -D convert.ops="hoot::UnconnectedWaySnapper" \
      -D snap.unconnected.ways.snap.way.criterion=hoot::HighwayCriterion \
      -D snap.unconnected.ways.snap.to.way.criterion=hoot::HighwayCriterion \
      -D snap.unconnected.ways.snap.to.way.node.criterion=hoot::HighwayWayNodeCriterion \
      -D snap.unconnected.ways.snap.to.way.status=Input1 \
      -D snap.unconnected.ways.snap.way.status=Input2 \
      input1.osm input2.osm output.osm
-----

===== Remove intra-map duplicates within a single map:

-----
    hoot de-duplicate input.osm output.osm
-----

===== Remove intra-map and inter-map duplicates across two maps:

-----
    hoot de-duplicate input1.osm input2.osm output1.osm output2.osm
-----

===== Remove only inter-map duplicates across two maps:

-----
    hoot de-duplicate input1.osm input2.osm output1.osm output2.osm --skip-intra-map
-----

===== Copy element IDs from one map to another where identical elements are found between them:

-----
    hoot sync-element-ids input1.osm input2.osm output.osm
-----

===== Generate a grid with regular shaped cells across an entire map:

-----
    hoot task-grid "input1.osm;input2.osm" output.geojson --uniform
-----

===== Generate a grid with regular shaped cells across a subset of a map:

-----
    hoot task-grid  "-71.4698,42.4866,-71.4657,42.4902" output.geojson --uniform
-----

===== Generate a grid with irregular shaped cells that will fit at most 1000 nodes each for an entire map:

-----
    hoot task-grid "input1.osm;input2.osm" output.geojson --maxNodesPerCell 1000 --node-density
-----

===== Generate a grid with irregular shaped cells that will fit at most 1000 nodes each for a subset of a map:

-----
    hoot task-grid "input1.osm;input2.osm" output.geojson \
      --maxNodesPerCell 1000 --bounds "-71.4698,42.4866,-71.4657,42.4902" --node-density
-----

===== Find street intersection locations in a map by street name:

-----
    hoot convert -D convert.ops="hoot::FindStreetIntersectionsByName" \
      -D name.criterion.names="streetName1;streetName2" -D name.criterion.case.sensitive=false \
      -D name.criterion.partial.match=false input.osm output.osm
-----

===== Create a shape that covers a set of features by manually specifying an alpha value:

-----
hoot alpha-shape --alpha 200 --buffer -10 input.osm 200 0 output.osm
-----

===== Create a shape that covers a set of features with automatic calculation of the alpha value:

-----
hoot alpha-shape --buffer 10 input.osm 200 0 output.osm
-----

==== Comparison

===== Calculate the difference between two maps:

-----
    hoot diff input1.osm input2.osm
-----

===== Compare two maps:

-----
    hoot compare input1.osm input2.osm

    Attribute Score 1: 981 +/-5
    Attribute Score 2: 993 +/-3
    Attribute Score: 987 +/-4 (983 to 991)
    Raster Score 1: 982
    Raster Score 2: 989
    Raster Score: 986
    Graph Score 1: 944 +/-19 (925 to 963)
    Graph Score 2: 996 +/-0 (996 to 996)
    Graph Score: 970 +/-10 (960 to 980)
    Overall: 981 +/-4 (977 to 985)

    # Compare tags between maps
    hoot tag-compare input1.osm input2.osm

    |                    | amenity=restaurant | building=yes | name=<NULL> | name=<SIMILAR> |
    | amenity=restaurant |                  4 |              |             |                |
    |       building=yes |                    |           28 |             |                |
    |        name=<NULL> |                    |              |           4 |                |
    |     name=<SIMILAR> |                    |              |             |             24 |
-----

==== Statistics

===== Display a set of statistics for a map:

-----
    hoot stats input.osm
-----

===== Count all features in a map:

-----
    hoot count input.osm
-----

===== Count all elements in a map:

-----
    hoot count input.osm --all-elements
-----

===== Count all the POIs multiple maps:

-----
    hoot count "input1.osm;input2.osm" hoot::PoiCriterion
-----

===== Count all features within a bounding box:

-----
    hoot count -D in.bounds.criterion.bounds="-77.0551,38.8845,-77.0281,38.9031" -D in.bounds.criterion.strict=true \
      input.osm hoot::InBoundsCriterion
-----

===== Show a summary of building conflation reviews by type and frequency:

-----
    hoot tag-distribution input.osm hoot:review:note hoot::ReviewRelationCriterion

    Total tag count: 129
    62	(48.1%)	unmatched buildings are overlapping
    20	(15.5%)	very little building overlap building orientation not similar building edges not very close to each other
    15	(11.6%)	very little building overlap similar building orientation building edges not very close to each other
    14	(10.9%)	very little building overlap semisimilar building orientation building edges not very close to each other
    12	(9.3%)	very little building overlap very similar building orientation building edges not very close to each other
    3	(2.33%)	small building overlap building orientation not similar building edges not very close to each other
    1	(<1%)	small building overlap similar building orientation building edges not very close to each other
    1	(<1%)	small building overlap semisimilar building orientation building edges not very close to each other
    1	(<1%)	medium building overlap building orientation not similar building edges not very close to each other
-----

===== Display a delimited list as a string of all tag keys in a map:

-----
    hoot tag-info --warn --keys-only --delimited-text input.osm
-----

=== Advanced

==== Conflation

===== Conflate two maps into a single map using Reference Conflation and the Network road matching algorithm:

-----
    hoot conflate -C NetworkAlgorithm.conf input1.osm input2.osm output.osm
-----

===== Conflate, adding geometry data from the second map to output that does not conflict with data in the first map (Differential Tag Only Conflation; tags may be overwritten):

-----
    hoot conflate -C DifferentialConflation.conf --include-tags input1.osm input2.osm output.osm --differential
-----

===== Conflate only tags from a second map into a first map without changing the first map's geometry (Attribute Conflation):

-----
    hoot conflate -C AttributeConflation.conf input1.osm input2.osm output.osm
-----

===== Assuming a first map is superior to a second, cut out the shape of the first map out from the area being conflated so that only data from the second map is stitched in around the first map (Horizontal Conflation (aka Cookie Cutter)):

-----
    hoot conflate -D conflate.pre.ops=hoot::CookieCutterOp -D cookie.cutter.alpha=2500 \
      -D cookie.cutter.alpha.shape.buffer=0 -D cookie.cutter.output.crop=false \
      input1.osm input2.osm output.osm
-----

===== Conflate only buildings:

-----
    hoot conflate -D match.creators="hoot::BuildingMatchCreator" \
      -D merger.creators="hoot::BuildingMergerCreator" input1.osm input2.osm output.osm
-----

===== Filter maps down to POIs only before conflating them:

-----
    hoot conflate -D conflate.pre.ops="hoot::RemoveElementsVisitor" \
      -D remove.elements.visitor.element.criteria="hoot::PoiCriterion" input1.osm input2.osm \
      output.osm
-----

===== Filter maps down to rivers only before conflating them:

-----
    hoot conflate -D convert.ops=hoot::RemoveElementsVisitor \
      -D remove.elements.visitor.element.criteria=hoot::LinearWaterwayCriterion;hoot::LinearWaterwayWayNodeCriterion;hoot::RelationWithRiverMembersCriterion \
      -D element.criterion.negate=true \
      -D remove.elements.visitor.chain.element.criteria=true \
      -D remove.elements.visitor.recursive=false input1.osm input2.osm output.osm
-----

===== Translate features to a schema before conflating them:

-----
    hoot conflate -D conflate.pre.ops="hoot::SchemaTranslationVisitor" \
      -D schema.translation.script=myTranslation.js input1.osm input2.osm output.osm
-----

===== Align a second map towards a first map before conflating them:

-----
    hoot conflate -D conflate.pre.ops="hoot::RubberSheet" -D rubber.sheet.ref=true input1.osm \
      input2.osm output.osm
-----

===== Preserve all values for a particular tag key during conflation:

-----
    # The value for myTagKey will consist of a semicolon delimited list of all the unique values 
    # found when merging features together.
    hoot conflate -D tag.merger.overwrite.accumulate.values.keys="myTagKey" input1.osm input2.osm
-----

===== Generate feature match scores between maps without merging them:

-----
    hoot conflate -D conflate.match.only=true -D writer.include.conflate.score.tags=true \
      input1.osm input2.osm output.osm
-----

==== Applying Changes

===== Derive a changeset between two maps and write the result directly to an OSM API database:

-----
    hoot changeset-derive inputData1.osm inputData2.osm changeset.osc.sql
    hoot changeset-apply changeset.osc.sql osmapidb://username:password@localhost:5432/databaseName
-----

==== Data Transformation

===== Convert an OSM file to a shape file, allowing the export columns to be automatically selected based on frequency:

-----
    hoot convert input.osm output.shp
-----

===== Bulk write a map to an offline OSM API database:

-----
    hoot convert -D changeset.user.id=1 \
      -D osmapidb.bulk.inserter.disable.database.constraints.during.write=true \
      -D osmapidb.bulk.inserter.disable.database.indexes.during.write=true \
      input.osm.pbf osmapidb://username:password@localhost:5432/database
-----

===== Bulk write a map to an offline OSM API database specifying starting element IDs:

-----
    hoot convert -D changeset.user.id=1 \
      -D osmapidb.bulk.inserter.disable.database.constraints.during.write=true \
      -D osmapidb.bulk.inserter.disable.database.indexes.during.write=true \
      -D apidb.bulk.inserter.starting.node.id=10 \
      -D apidb.bulk.inserter.starting.way.id=10 -D apidb.bulk.inserter.starting.relation.id=10 \
      input.osm.pbf osmapidb://username:password@localhost:5432/database
-----

===== Bulk write a map to an online OSM API database (element IDs managed automatically):

-----
    hoot convert -D changeset.user.id=1 \
      -D osmapidb.bulk.inserter.reserve.record.ids.before.writing.data=true \
      input.osm.pbf osmapidb://username:password@localhost:5432/database
-----

===== Remove relations from a map:

-----
    hoot convert -D convert.ops="hoot::RemoveElementsVisitor" \
      -D remove.elements.visitor.element.criteria="hoot::RelationCriterion" input.osm output.osm
-----

===== Remove all but two specific relations:

-----
    hoot convert -D convert.ops="hoot::RemoveElementsVisitor" \
    -D remove.elements.visitor.element.criteria="hoot::ElementIdCriterion" 
    -D element.id.criterion.ids="Relation:-1;Relation:7387470" 
    -D element.criterion.negate=true input.osm output.osm
-----

===== Remove relations and ways from a map:

-----
    hoot convert -D convert.ops="hoot::RemoveElementsVisitor" \
      -D remove.elements.visitor.element.criteria="hoot::RelationCriterion;hoot::WayCriterion" input.osm output.osm
-----

===== Remove everything but polygon geometries and their constituent features from a map:

-----
    hoot convert -D convert.ops="hoot::RemoveElementsVisitor" \
      -D remove.elements.visitor.element.criteria="hoot::PolygonCriterion" -D element.criterion.negate=true \ 
      input.osm output.osm
-----

===== Mark exact duplicate features within a map:

-----
    hoot convert -D convert.ops="hoot::DuplicateElementMarker" input.osm output.osm
-----

===== Remove all duplicate ways from a map:

-----
    hoot convert -D convert.ops="hoot::DuplicateWayRemover" input.osm output.osm
-----

===== Remove all duplicate areas from a map:

-----
    hoot convert -D convert.ops="hoot::RemoveDuplicateAreasVisitor" input.osm output.osm
-----

===== Remove all empty areas from a map:

-----
    hoot convert -D convert.ops="hoot::RemoveEmptyAreasVisitor" input.osm output.osm
-----

===== Remove duplicate name tags from features:

-----
    hoot convert -D convert.ops="hoot::DuplicateNameRemover" input.osm output.osm
-----

===== Remove duplicate nodes:

-----
    hoot convert -D convert.ops="hoot::DuplicateNodeRemover" input.osm output.osm
-----

===== Remove elements that contain no useful information:

-----
    hoot convert -D convert.ops="hoot::NoInformationElementRemover" input.osm output.osm
-----

===== Combine like polygons together without using full-fledged conflation:

-----
    hoot convert -D convert.ops="hoot::UnionPolygonsOp" input.osm output.osm
-----

===== Add the tag "error:circular=5.0" to all elements:

-----
    hoot convert -D convert.ops=hoot::SetTagValueVisitor -D set.tag.value.visitor.keys=error:circular \
      -D set.tag.value.visitor.values=5.0 input.osm output.osm
-----

===== Add the tag "error:circular=5.0" to all relations and their members: 

-----
    hoot convert -D convert.ops=hoot::RecursiveSetTagValueOp -D set.tag.value.visitor.keys=error:circular \
      -D set.tag.value.visitor.values=5.0 -D set.tag.value.visitor.criterion=hoot::RelationCriterion \ 
      input.osm output.osm
-----

===== Remove all "source" and "error:circular" tags from ways:

-----
    hoot convert -D convert.ops="hoot::RemoveTagsVisitor" \
      -D tag.filter.element.criterion="hoot::WayCriterion" \
      -D tag.filter.keys="source;error:circular" input.osm output.osm
-----

===== Remove all tag keys starting with "source" from ways:

-----
    hoot convert -D convert.ops="hoot::RemoveTagsVisitor" \
      -D tag.filter.element.criterion="hoot::WayCriterion" \
      -D tag.filter.keys="source*" input.osm output.osm
-----

===== Remove all elements that have the tag "status=proposed":

-----
    hoot convert -D convert.ops=hoot::RemoveElementsVisitor \
      -D remove.elements.visitor.filter=hoot::TagCriterion -D tag.criterion.kvps="status=proposed"
-----

===== Remove all tags with keys "REF1" and "REF2" from elements containing the tag "power=line":

-----
    hoot convert -D convert.ops=hoot::RemoveTagsVisitor -D tag.filter.keys="REF1;REF2" \
      -D tag.filter.element.criterion=hoot::TagCriterion \
      -D tag.criterion.kvps="power=line" -D element.criterion.negate=true input.osm output.osm
-----

===== For all features with a "voltage" tag between 1 and 45k volts, set the tag "power=minor_line":

-----
    hoot convert -D convert.ops=hoot::SetTagValueVisitor -D set.tag.value.visitor.keys=power \
      -D set.tag.value.visitor.values=minor_line \
      -D set.tag.value.visitor.element.criteria="hoot::TagValueNumericRangeCriterion" \
      -D tag.value.numeric.range.criterion.keys=voltage \
      -D tag.value.numeric.range.criterion.min=1 -D tag.value.numeric.range.criterion.max=45000 \
      input.osm output.osm
-----

==== Add missing attributes to corrupted elements:

-----
    hoot convert -D convert.ops="hoot::AddAttributesVisitor" \
      -D add.attributes.visitor.kvps="changeset=1" input.osm output.osm
-----

==== Utilities

===== Crop a map while not splitting features that cross the bounds:

-----
    hoot crop -D crop.keep.entire.features.crossing.bounds=true input.osm output.osm "-77.0551,38.8845,-77.0281,38.9031"
-----

===== Crop a map and keep only features completely inside the bounds:

-----
    hoot crop -D crop.keep.only.features.inside.bounds=true input.osm output.osm "-77.0551,38.8845,-77.0281,38.9031"
-----

===== Crop a map in reverse and keep only features outside of the bounds:

-----
    hoot crop -D crop.invert=true input.osm output.osm "-77.0551,38.8845,-77.0281,38.9031"
-----

===== Put out a random subset of data with a maximum node size from a large input dataset (useful during conflation testing):

-----
    hoot crop-random input.osm output.osm 5000
-----

===== Sort data to the OSM standard that is too large to fit in memory:

-----
    hoot sort -D element.sorter.element.buffer.size=10000 input.osm output.osm
-----

===== Detect road intersections:

-----
    hoot convert -D convert.ops="hoot::FindHighwayIntersectionsOp" input.osm output.osm
-----

===== Create a node density plot:

-----
    hoot plot-node-density input.osm output.png 100
-----

===== Detect railway intersections:

-----
hoot convert -D convert.ops="hoot::FindRailwayIntersectionsOp" input.osm output.osm
-----

===== Make a perturbed copy of a map:

-----
    hoot perturb input.osm perturbed.osm
-----

===== Make a perturbed copy of a map with some adjusted input parameters:

-----
    hoot perturb -D perty.search.distance=20 -D random.way.generalizer.probability=0.7 \
      input.osm perturbed.osm
-----

===== Make a perturbed copy of a map, conflate the original map against the perturbed copy, and score how well the conflation performed:

-----
    hoot perturb input.osm /my/output/directory --score
-----

===== Run a series of random map perturbations and score how well all of them conflate against a source map:

-----
    hoot perturb -D perty.test.num.runs=10 -D perty.test.num.simulations=5 \
      -D perty.test.dynamic.variables=perty.systematic.error.x;perty.systematic.error.y \
      -D perty.test.dynamic.variable.start.value=1.0 \
      -D perty.test.dynamic.variable.increment=5.0 \
      -D perty.test.expected.scores=0.9;0.95;0.93;0.952;0.91;0.95;0.9;0.95;0.95;0.95 \
      -D perty.test.allowed.score.variance=0.05 reference-in.osm /my/output/directory --test
-----

===== Display the internal tag schema that Hootenanny uses:

-----
    hoot schema
-----

===== Obtain a similarity score for two type tags based on the internal schema:

-----
    hoot type-similarity amenity=school landuse=residential
-----

===== Split a map into multiple maps corresponding to irregular shaped tiles produced above:

-----
    hoot split output.geojson input.osm output.osm
-----

===== Normalize all the element address tags in a map:

-----
    hoot convert -D convert.ops="hoot::NormalizeAddressesVisitor" input.osm output.osm
-----

===== Normalize all the element phone number tags in a map:

-----
    hoot convert -D convert.ops="hoot::NormalizePhoneNumbersVisitor" input.osm output.osm
-----

===== Add admin boundary level location tags associated with element phone numbers:

-----
    hoot convert -D convert.ops="hoot::PhoneNumberLocateVisitor" input.osm output.osm
-----

===== Snap unconnected roads in one dataset back to neighboring roads in another dataset using a stricter feature type matching requirement:

-----
    hoot convert -D convert.ops="hoot::UnconnectedWaySnapper" \
      -D snap.unconnected.ways.minimum.type.match.score=0.8 \
      -D snap.unconnected.ways.snap.way.criterion=hoot::HighwayCriterion \
      -D snap.unconnected.ways.snap.to.way.criterion=hoot::HighwayCriterion \
      -D snap.unconnected.ways.snap.to.way.node.criterion=hoot::HighwayWayNodeCriterion \
      -D snap.unconnected.ways.snap.to.way.status=Input1 \
      -D snap.unconnected.ways.snap.way.status=Input2 \
      input1.osm input2.osm output.osm
-----

===== Snap unconnected roads in one dataset back to neighboring roads in another dataset and mark them as needing review:

-----
    hoot convert -D convert.ops="hoot::UnconnectedWaySnapper" \
      -D snap.unconnected.ways.snap.way.criterion=hoot::HighwayCriterion \
      -D snap.unconnected.ways.snap.to.way.criterion=hoot::HighwayCriterion \
      -D snap.unconnected.ways.snap.to.way.node.criterion=hoot::HighwayWayNodeCriterion \
      -D snap.unconnected.ways.snap.to.way.status=Input1 \
      -D snap.unconnected.ways.snap.way.status=Input2 \
      -D snap.unconnected.ways.review.snapped=true \
      input1.osm input2.osm output.osm
-----

===== Mark unconnected roads as needing review in one dataset that could be snapped back to neighboring roads in another dataset:

-----
    hoot convert -D convert.ops="hoot::UnconnectedWaySnapper" \
      -D snap.unconnected.ways.snap.way.criterion=hoot::HighwayCriterion \
      -D snap.unconnected.ways.snap.to.way.criterion=hoot::HighwayCriterion \
      -D snap.unconnected.ways.snap.to.way.node.criterion=hoot::HighwayWayNodeCriterion \
      -D snap.unconnected.ways.snap.to.way.status=Input1 \
      -D snap.unconnected.ways.snap.way.status=Input2 \
      -D snap.unconnected.ways.review.snapped=true \
      -D snap.unconnected.ways.mark.only=true \
      input1.osm input2.osm output.osm
-----

===== Simplify ways in a map by removing unnecessary nodes from them:

-----
    hoot convert -D convert.ops="hoot::WayGeneralizeVisitor" -D way.generalizer.epsilon=5.0 input.osm output.osm
-----

===== Remove intra-map exact duplicates within a single map but skip removing nodes:

-----
    hoot de-duplicate input.osm output.osm --skip-nodes
-----

===== Remove intra-map exact duplicates within a single map with a node filter:

-----
    hoot de-duplicate input.osm output.osm --node-filter "hoot::PoiCriterion"
-----

===== Generate a grid based on node density, specifying the maximum allowed node count per grid cell and a pixel size:

--------------------------------------
hoot task-grid "test-files/MyInputFile1.osm;test-files/MyInputFile2.osm" MyOutputFile.geojson \
   --maxNodesPerCell 1000 --pixelSize 0.001 --node-density
--------------------------------------

===== Calculate a grid based on node density, specifying the maximum allowed node count per cell, a pixel size, 
and allow for more than one calculation attempt:

--------------------------------------
hoot task-grid "test-files/MyInputFile1.osm;test-files/MyInputFile2.osm" MyOutputFile.geojson \
  --maxNodesPerCell 1000 --pixelSize 0.001 --maxAttempts 5 --pixelSizeAutoReductionFactor 10 --node-density
--------------------------------------

===== Select a random grid cell based on node density (works for --uniform as well):

--------------------------------------
hoot task-grid test-files/MyInputFile.osm MyOutputFile.geojson --random --node-density
--------------------------------------

===== Select a random grid cell based on node density specifying a particular seed for the random number 
generator (works for --uniform as well):

--------------------------------------
hoot task-grid test-files/MyInputFile.osm MyOutputFile.geojson --maxNodesPerCell 1000 \
  --pixelSize 0.001 --random --randomSeed 2 --node-density
--------------------------------------

==== Statistics

===== Count all elements that are not POIs:

-----
    hoot count -D element.criterion.negate=true "input1.osm;input2.osm" hoot::PoiCriterion \
      --all-elements
-----

===== Count all features which have a tag whose key contains the text "phone":

-----
    hoot count -D tag.key.contains.criterion.text="phone" input.osm hoot::TagKeyContainsCriterion
-----

===== Count all features which have a name:

-----
    hoot count input.osm hoot::HasNameCriterion
-----

===== Count all features which have the name, "Old Town Tavern":

-----
    hoot count -D name.criterion.names="Old Town Tavern" -D name.criterion.case.sensitive=false \
      input.osm hoot::NameCriterion
-----

===== Count all features whose name contains "subway":

-----
    hoot count -D name.criterion.names="subway" -D name.criterion.case.sensitive=false \
      input.osm hoot::NameCriterion
-----

===== Calculate the area of all features in a map:

-----
    hoot stat input.osm hoot::CalculateAreaVisitor
-----

===== Calculate the length of all ways in a map:

-----
    hoot stat input.osm hoot::LengthOfWaysVisitor
-----

===== Count the number of features containing a node by specifying its ID:

-----
    hoot count -D contains.node.criterion.id=-234 input.osm hoot::ContainsNodeCriterion
-----

===== Count the number of nodes within 25 meters of a coordinate:

-----
    hoot count -D distance.node.criterion.center=-77.3453,38.3456 \
      -D distance.node.criterion.distance=25.0 input.osm hoot::DistanceNodeCriterion
-----

===== Count the number of elements with a version greater than or equal to one:

-----
    hoot count -D attribute.value.criterion.type=version \
      -D attribute.value.criterion.comparison.type=NumericGreaterThanOrEqualTo \
      -D attribute.value.criterion.comparison.value=1 input.osm hoot::AttributeValueCriterion
-----

===== Count the number of elements authored by "username":

-----
    hoot count -D attribute.value.criterion.type=user \
      -D attribute.value.criterion.comparison.type=TextEqualTo \
      -D attribute.value.criterion.comparison.value="username" input.osm hoot::AttributeValueCriterion
-----

===== Calculate the average number of nodes for a set of buildings:

-----
hoot stat -D nodes.per.way.visitor.element.criterion=hoot::BuildingCriterion input.osm hoot::NodesPerWayVisitor average
-----

===== Calculate the numerical average of all "accuracy" tags:

-----
    hoot stat -D tags.visitor.keys="accuracy" input.osm hoot::AverageNumericTagsVisitor
-----

===== Display the distribution of highway tags for roads in a map; This result shows that highway=road made up over 97% of all highway tags in the data:

-----
    hoot tag-distribution input.osm highway hoot::HighwayCriterion

    365	(97.59%)	road
    9	(2.41%)		motorway
-----

===== Display tag schema information for a map

-----
    hoot tag-info input.osm

    .{
    "ca-Transmission_Line-state-gov.shp":{
    "ca-Transmission_Line-state-gov":{
      "Circuit":[
        "Double",
        "Duble",
        "Liberty Energy",
        "Many",
        "Quad",
        "Single"
        ],
      "Comments":[
        "Attached to 115kv poles",
        "Caldwell-victor 220kv",
        "Changed kv from 115 to 60kv",
        "Distribution line",
        ...
        ],
      "Legend":[
        "IID_161kV",
        "IID_230kV",
        "IID_34.5_92kV",
        "LADWP_115_138kV",
        ...
        ],
        ...
    }}
-----

===== Display occurrence frequencies of tokenized feature names:

-----
    hoot tag-distribution input.osm --names --tokenize --limit 5

    320	(6.81%)	nw
    246	(5.24%)	st
    80	(1.70%)	ave
    45	(0.96%)	sw
    18	(0.38%)	h
-----

===== Count the number of elements with valid address tags in a map:

-----
    hoot count input.osm hoot::HasAddressCriterion
-----

===== Count the total number of valid address tags in a map:

-----
    hoot stat input.osm hoot::AddressCountVisitor
-----

===== Count the number of elements with valid phone number tags in a map:

-----
    hoot count input.osm hoot::HasPhoneNumberCriterion
-----

===== Count the total number of valid phone number tags in a map:

-----
    hoot stat input.osm hoot::PhoneNumberCountVisitor
-----

==== Add Missing Type Tags

===== Attempt to add missing type tags to POIs and buildings:

-----
    hoot convert -D convert.ops=hoot::ImplicitPoiPolygonTypeTagger input.osm output.osm
-----

===== Attempt to add missing type tags to POIs and buildings before conflating them:

-----
    hoot convert -D conflate.pre.ops=hoot::ImplicitPoiPolygonTypeTagger input1.osm input2.osm \
      output.osm
-----

==== Language Translation

Requires language translation server installation.  See the Hootenanny Install Guide for details.

===== Translate "name" and "alt_name" tags from German or Spanish to English:

-----
    hoot convert -D convert.ops="hoot::ToEnglishTranslationVisitor" \
      -D language.translation.source.languages="de;es" \
      -D language.tag.keys="name;alt_name" input.osm output.osm
-----

===== Automatically determine all the name tags in the source map and then translate those tags to English, allowing the source language to first be detected:

-----
    hoot convert -D convert.ops="hoot::ToEnglishTranslationVisitor" \
      -D language.translation.source.languages="detect" \
      -D language.parse.names=true input.osm output.osm
-----

===== Translate names to English before conflation, allowing the source language to first be detected:

-----
    hoot conflate -D conflate.pre.ops="hoot::ToEnglishTranslationVisitor" \
      -D language.translation.source.languages="detect" \
      -D language.translation.to.translate.tag.keys="name" input1.osm input2.osm output.osm
      -D language.tag.keys="name" input.osm output.osm
-----

===== Determine the most prevalent source languages for non-English POI names in a map. Use that information to set up English translation services for those languages:

-----
    hoot convert -D language.parse.names=true \
      -D convert.ops="hoot::PoiCriterion;hoot::NonEnglishLanguageDetectionVisitor" \
      input.osm output.osm
-----

==== MetaInfo

===== List all configuration option names and their descriptions:

-----
    hoot info --config-options --option-details
-----

===== List all configuration option names containing "poi.polygon":

-----
    hoot info --config-options poi.polygon --option-names
-----

===== List all criteria that identify conflatable features:

-----
    hoot info --conflatable-criteria
-----

===== List all operators configured to run after conflation:

-----
    hoot info --conflate-post-operations
-----

===== List all operators configured to run before conflation:

-----
    hoot info --conflate-pre-operations
-----

===== List all operators that can take an element criterion as input:

-----
    hoot info --criterion-consumers
-----

===== List all extractors used to score feature properties:

-----
    hoot info --feature-extractors
-----

===== List all input formats that support reading by geospatial bounds:

-----
    hoot info --formats --input-bounded
-----

===== List all input formats that support streamable reading:

-----
    hoot info --formats --input-streamable
-----

===== List all output formats that support streamable writing:

-----
    hoot info --formats --output-streamable
-----

===== List all input formats that Hootenanny uses OGR to read:

-----
    hoot info --formats --input --ogr
-----

===== List all output formats that Hootenanny uses OGR to write:

-----
    hoot info --formats --output --ogr
-----

===== List all criteria that can be used to identify a feature's geometry type:

-----
    hoot info --geometry-type-criteria
-----

===== List all language detectors:

-----
    hoot info --languages --detectors
-----

===== List all language translators:

-----
    hoot info --languages --translators
-----

===== List all detectable languages:

-----
    hoot info --languages --detectable
-----

===== List all translatable languages:

-----
    hoot info --languages --translatable
-----

===== List all entities that can match features:

-----
    hoot info --matchers
-----

===== List all entities that can create feature matchers:

-----
    hoot info --match-creators
-----

===== List all entities that can merge features:

-----
    hoot info --mergers
-----

===== List all entities that can create feature mergers:

-----
    hoot info --merger-creators
-----

===== List all entities that can operate on data:

-----
    hoot info --operators
-----

===== List all entities that can filter data (a subset of --operators):

-----
    hoot info --filters
-----

===== List all entities that can compare strings:

-----
    hoot info --string-comparators
-----

===== List all entities capable of subline matching:

-----
    hoot info --subline-matchers
-----

===== List all entities capable of subline string matching:

-----
    hoot info --subline-string-matchers
-----

===== List all entities capable of tag merging:

-----
    hoot info --tag-mergers
-----

===== List all entities capable of aggregating tag values:

-----
    hoot info --value-aggregators
-----

===== List all way joiners:

-----
    hoot info --way-joiners
-----

