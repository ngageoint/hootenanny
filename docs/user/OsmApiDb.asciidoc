
== Working with OpenStreetMap Editing API Database Data in Hootenanny 

Hootenanny offers the capability to convert data between an OpenStreetMap Editing API Database and any supported Hootenanny data output format.  The OpenStreetMap Editing API database allows fetching and saving of raw geo-data for OpenStreetMap.  The current supported API version is 0.6. More information about the database and API is found at: http://http://wiki.openstreetmap.org/wiki/API. 

Hootenanny supports reading and writing from the OpenStreetMap API database using its 'convert' command.  A description of how to use Hootenanny's capability for 'writing to' and 'reading from' an OpenStreetMap Editing API Database is described in this section. 

Postgres database tuning is very important to support large data ingests.  The Hootenanny default Postgres database instance comes
with moderate tuning, but you may need to perform additional tuning for your database.  Postgres tuning is outside of the scope of this document, so visit the Postgres website for more information.

=== Configuring an OSM API Database Connection

If you want to make use of an OSM API Database from within the Hootenanny iD Editor UI, you must configure Hootenanny to use your OSM API database (only one database at a time is supported).  See "Configuring an OSM API Database Connection" section of the Hootenanny Installation Guide for instructions.

If you are using Hootenanny from the command line no configuration is required, and you can simply reference a URL to your OSM API database within the command.  See the 'hoot convert' documentation for details on the URL format (also examples below).

=== Creating an OSM API Database

If you do not already have an OSM API database available, you can run the following:

----------------------------
$HOOT_HOME/scripts/database/CleanAndInitializeOsmApiDb.sh
-------------------------------

This will create an empty OSM API database with a single test user.  The test database has this URL: 

osmapidb://hoot:hoottest@localhost:5432/osmapi_test

=== Writing to an OpenStreetMap Editing API Database Using the Command Line

Hootenanny's 'hoot convert' command uses optimized SQL routines to write large amounts of data to the OSM API database, which results in much faster performance than using XML changesets passed to the OSM web services over HTTP (Rails Port).  The writer
has two possible workflows: online and offline.  The offline mode is meant for the fastest performance writing against offline
databases (no other writers present), while the online mode sacrifices some performance but is safe for writing against online databases (other writers present).

Its easiest to demonstrate the two workflows with some examples:

==== Use Case #1 (offline) ==== 

Write to a SQL file or CSV files and handle all record ID updates outside of Hootenanny:
-----------------
hoot convert -D changeset.user.id=1 myOsmDataInput.osm.pbf myOsmDataOutput.sql
-----------------

Write directly to a database and handle all record ID updates outside of Hootenanny:
-----------------
hoot convert -D changeset.user.id=1 myOsmDataInput.osm.pbf osmapidb://hoot:hoottest@localhost:5432/osmapi_test
-----------------

Write directly to a database, handle all record ID updates outside of Hootenanny, and retain the SQL output file:
-----------------
hoot convert -D changeset.user.id=1 -D osmapidb.bulk.writer.output.files.copy.location=myOsmDataOutput.sql myOsmDataInput.osm.pbf osmapidb://hoot:hoottest@localhost:5432/osmapi_test
-----------------

==== Use Case #2 (offline) ==== 

Write to a SQL file or CSV files and manually specify record starting IDs with Hootenanny:
-----------------
hoot convert -D changeset.user.id=1 -D osmapidb.bulk.writer.starting.node.id=10 -D osmapidb.bulk.writer.starting.way.id=10 -D osmapidb.bulk.writer.starting.relation.id=10 myOsmDataInput.osm.pbf myOsmDataOutput.sql
-----------------

Write directly to a database and manually specify record starting IDs with Hootenanny:
-----------------
hoot convert -D changeset.user.id=1 -D osmapidb.bulk.writer.starting.node.id=10 -D osmapidb.bulk.writer.starting.way.id=10 -D osmapidb.bulk.writer.starting.relation.id=10 myOsmDataInput.osm.pbf osmapidb://hoot:hoottest@localhost:5432/osmapi_test
-----------------

Write directly to a database, manually specify record starting IDs with Hootenanny, and retain the SQL output file:
-----------------
hoot convert -D changeset.user.id=1 -D osmapidb.bulk.writer.starting.node.id=10 -D osmapidb.bulk.writer.starting.way.id=10 -D osmapidb.bulk.writer.starting.relation.id=10 -D osmapidb.bulk.writer.output.files.copy.location=myOsmDataOutput.sql myOsmDataInput.osm.pbf osmapidb://hoot:hoottest@localhost:5432/osmapi_test
-----------------

==== Use Case #3 (online) ==== 

Write to a SQL file and reserve a range of record IDs so that you can execute the SQL at a later time against a live database safely:
-----------------
hoot convert -D changeset.user.id=1 -D osmapidb.bulk.writer.reserve.record.ids.before.writing.data=true myOsmDataInput.osm.pbf myOsmDataOutput.sql
-----------------

Write directly to a database and reserve a range of record IDs so that you can execute the SQL at a later time against a live database safely:
-----------------
hoot convert -D changeset.user.id=1 -D osmapidb.bulk.writer.reserve.record.ids.before.writing.data=true myOsmDataInput.osm.pbf osmapidb://hoot:hoottest@localhost:5432/osmapi_test
-----------------

Write directly to a database, eserve a range of record IDs so that you can execute the SQL at a later time against a live database safely, and retain the SQL output file:
-----------------
hoot convert -D changeset.user.id=1 -D osmapidb.bulk.writer.reserve.record.ids.before.writing.data=true -D osmapidb.bulk.writer.output.files.copy.location=myOsmDataOutput.sql myOsmDataInput.osm.pbf osmapidb://hoot:hoottest@localhost:5432/osmapi_test
-----------------

When 'osmapidb.bulk.writer.reserve.record.ids.before.writing.data' is set to true, the data write operation is completely 
record ID safe, meaning that it can be used while other concurrent users are writing to the target database without fear of 
record ID conflicts.

If you are writing extreme amounts of data and have adequate memory available, you may be able to improve the performance of the write operation with additional tweaks.  The configuration option, 'osmapidb.bulk.writer.file.output.buffer.max.line.size', determines how many file lines are held in memory before they are flushed out to disk when generating the output files.  The default setting is fairly large, but you may be able to improve write performance by increasing it (conversely, if your memory is limited, you may need to decrease this setting).  This optimization deals *only* with the output file generation, however, and does nothing to increase the performance of the SQL execution against the target database (database tuning may help there).

The configuration option, 'osmapidb.bulk.writer.file.output.status.update.interval', simply determines how often you see progress updates when generating the output files.  The default value is fairly large, but for very large amounts of data you may wish to increase the value of this option to avoid too frequent of progress update messages.

IMPORTANT: The configuration option, 'changeset.user.id', is required and must match a valid user ID in your OSM API database.  All writes you do with 'hoot convert' will be associated with this user ID.

IMPORTANT: OSM PBF (.osm.pbf) is currently the most efficient OSM source format for writing large amounts of data to an OSM API database, as Hootenanny is able to stream in the data during reading in a buffered fashion and, thus, avoid memory constraints.  Reading the .osm XML file format is currently memory bound with Hootenanny and using it as a source file type when writing to an OSM API database may fail if your system does not have enough memory to support loading the entire file.  The process of writing the data to the OSM API database is, however, not memory bound.  See the 'hoot convert' command documentation for details on which geodata formats are currently memory bound for both reading and writing with Hootenanny.

See the User Guide descriptions of all settings prefixed with "osmapidb.bulk.writer" for a complete overview of the OSM API database writing options available.

=== Reading from an OpenStreetMap Editing API Database

Reading from an OpenStreetMap Editing API database requires the use of Hootenanny's 'convert' command and the following command arguments described here:

------
% Hootenanny 'convert' command: hoot convert [args] input output

% Input source:
a sample OpenStreetMap Edit API Database: osmapidb://hoot:hoottest@localhost:5432/osmapi_test  This database is the test database and should be active for testing. However, any database input source may be supplied here. 

% Output destination:
define an output osm file: /tmp/ToyTestA-out.osm

% Command syntax example:

hoot convert osmapidb://hoot:hoottest@localhost:5432/osmapi_test test-output/ToyTestA-out.osm

hoot convert -D convert.bounding.box=-106.5100000,38.3000000,-106.4000000,38.5000000 osmapidb://hoot:hoottest@localhost:5432/osmapi_test test-output/bboxOutput.osm
------

=== Validating Writes to the OpenStreetMap Editing API Database

After writing to the OpenStreetMap Editing API Database, the data can be validated by performing the following steps:

------
% Dump DB
pg_dump -U hoot -h localhost -p 5432 osmapi_test -a > /tmp/ToyTestA-dump.sql
% password=hoottest
% Note: Assume ToyTestA.osm was written to the db previously
% Note: Assume the arg -D services.db.writer.output.id.mapping=/tmp/idmaps.xml was used 
  when writing.

% Install dependencies for the compare script
sudo apt-get install libxml-simple-perl

% Compare input with the dumped output
time $HOOT_HOME/scripts/compareOsmXmlToOsmApiDbDump $HOOT_HOME/test-files/ToyTestA.osm /tmp/idmaps.xml /tmp/ToyTestA-dump.sql
------ 

The sample output for validating the write operation using ToyTestA.osm should look something like this:

------
OSM XML file: ./test-files/ToyTestA.osm
PostgreSQL dump file: /tmp/ToyTestA-dump.sql

Validating data: nodes
current_nodes, current_node_tags:
Matching number of nodes: PASS (36)
Deep inspection of data integrity: PASS
nodes, node_tags:
Matching number of nodes: PASS (36)
Deep inspection of data integrity: PASS

Validating data: ways
current_ways, current_way_tags, current_way_nodes:
Matching number of ways: PASS (4)
Deep inspection of data integrity: PASS
ways, way_tags, way_nodes:
Matching number of ways: PASS (4)
Deep inspection of data integrity: PASS

Validating relations: ways
current_relations, current_relation_tags, current_relation_nodes:
Matching number of relations: PASS (0)
Deep inspection of data integrity: PASS
relations, relation_tags, relation_nodes:
Matching number of relations: PASS (0)
Deep inspection of data integrity: PASS

real 0m0.086s
user 0m0.082s
sys 0m0.004s
------

=== Validating Reads from the OpenStreetMap Editing API Database

After reading from the OpenStreetMap Editing API Database, the data can be validated by performing the following steps:

------
% Dump DB
pg_dump -U hoot -h localhost -p 5432 osmapi_test -a > /tmp/ToyTestA-dump.sql
% password=hoottest
% Note: Assume ToyTestA.osm was written to the database previously

% create new idmaps xml (idmaps2.xml) from the output data file
./generateIdMapXmlFromOsm /tmp/ToyTestA-out.osm /tmp/idmaps2.xml
% Note: Assume ToyTestA-out.osm was read from the db and written to file 

% compare the output with the database 
time scripts/compareOsmXmlToOsmApiDbDumpWriter /tmp/ToyTestA-out.osm /tmp/idmaps2.xml /tmp/ToyTestA-dump.sql
------ 

The reading validation output should be similar to the output for the writing validation.  If there is a mismatch, then contact the developer with the result so that the software can be checked for bugs.
 
