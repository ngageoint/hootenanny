[
    {
        "id":"hoot_cleaning_options",
        "elem_type":"group",
        "description":"A list of map operations to be applied to a map for cleaning purposes in order",
        "name":"Cleaning Options",
        "hoot_key":"map.cleaner.transforms",
        "members":[
            {
                "id":"hoot_enable_cleaning_options",
                "elem_type":"checkbox",
                "description":"Enable cleaning options",
                "name":"Enabled",
                "defaultvalue":"true",
                "onchange":"true"
            },
            {
                "id":"hoot_checkall_cleaning_options",
                "elem_type":"checkbox",
                "description":"Select or deselect all cleaning options",
                "name":"Select All",
                "defaultvalue":"false",
                "onchange":"true"
            },
            {
                "id":"reproject_to_planar_option",
                "elem_type":"checkbox",
                "description":"Before any cleaning, reproject to a planar projection (e.g. UTM).",
                "name":"Reproject To Planar Option",
                "hoot_val":"ReprojectToPlanarOp",
                "required":"true",
                "defaultvalue":"true"
            },
            {
                "id":"one_way_road_standardizer",
                "elem_type":"checkbox",
                "description":"Standardize one way street tags.",
                "name":"One Way Road Standardizer",
                "hoot_val":"OneWayRoadStandardizer",
                "defaultvalue":"true"
            },
            {
                "id":"duplicate_way_remover",
                "elem_type":"checkplus",
                "override":{
                    "elem_type":"checkplus"
                },
                "description":"Remove duplicate ways (lines) that are exact duplicates. If the lines partially overlap with exactly the same geometry then only the partial overlap is removed from the more complex geometry.",
                "name":"Remove Duplicate Ways",
                "hoot_val":"DuplicateWayRemover",
                "onchange":"true",
                "defaultvalue":"true"
            },
            {
                "id":"superfluous_way_remover",
                "elem_type":"checkbox",
                "description":"Remove all ways that contain no nodes or all the nodes are exactly the same.",
                "name":"Remove Superfluous Ways",
                "hoot_val":"SuperfluousWayRemover",
                "defaultvalue":"true"
            },
            {
                "id":"roundabout_handler",
                "elem_type":"checkbox",
                "description":"Remove / Replace roundabouts.",
                "name":"Handle Roundabouts",
                "hoot_val":"RemoveRoundabouts",
                "defaultvalue":"false"
            },
            {
                "id":"intersection_splitter",
                "elem_type":"checkbox",
                "description":"Split all roads that intersect.  Disabling this setting may have an extreme impact on conflation performance.",
                "name":"Split Intersections",
                "hoot_val":"IntersectionSplitter",
                "defaultvalue":"true"
            },
            {
                "id":"unlikely_intersection_remover",
                "elem_type":"checkbox",
                "description":"Remove implied intersections that are likely incorrect. For example, a motorway overpass intersecting a residential street at a 90Â° is considered unlikely and \"unsnapped\". The geometry location is not modified.",
                "name":"Remove Unlikely Intersections",
                "hoot_val":"UnlikelyIntersectionRemover",
                "defaultvalue":"true"
            },
            {
                "id":"dual_way_splitter",
                "elem_type":"checkbox",
                "description":"Split highway types that are marked as divided into two separate geometries marked as oneway roads. A number of assumptions must be made to do this including assumptions about the direction of travel on roads (right or left hand drivers).",
                "name":"Split Dual Ways",
                "hoot_val":"DualHighwaySplitter",
                "defaultvalue":"true"
            },
            {
                "id":"implied_divided_marker",
                "elem_type":"checkbox",
                "description":"If two roads implicitly should be marked as divided based on the surrounding roads, mark it as such. This is primarily caused by the FACC+ spec which does not allow bridges to be marked as divided.",
                "name":"Divided Road Marker Implied",
                "hoot_val":"HighwayImpliedDividedMarker",
                "defaultvalue":"true"
            },
            {
                "id":"duplicate_name_remover",
                "elem_type":"checkbox",
                "description":"Remove any duplicate names. See `duplicate.name.case.sensitive` for modifying the case sensitivity.",
                "name":"Remove Duplicate Names",
                "hoot_val":"DuplicateNameRemover",
                "required":"true",
                "defaultvalue":"true"
            },
            {
                "id":"small_way_merger",
                "elem_type":"checkplus",
                "override":{
                    "elem_type":"checkplus"
                },
                "description":"Merge any ludicrously small ways that have essentially the same attributes. Things like `UUID` are ignored. See `small.highway.merger.threshold` for setting the threshold value.",
                "name":"Merge Small Ways",
                "hoot_val":"SmallHighwayMerger",
                "onchange":"true",
                "defaultvalue":"true",
                "members":[
                    {
                        "id":"small_way_merger_threshold",
                        "minvalue":"0.01",
                        "elem_type":"double",
                        "description":"If highways are smaller than threshold and the tags matched then they will be merged together into a single way.",
                        "maxvalue":"",
                        "name":"Small Highway Merger Threshold",
                        "defaultvalue":"15",
                        "hoot_key":"small.highway.merger.threshold"
                    }
                ]
            },
            {
                "id":"remove_empty_areas_visitor",
                "elem_type":"checkbox",
                "description":"Remove all area elements that have a area of zero.",
                "name":"Remove Empty Areas",
                "hoot_val":"RemoveEmptyAreasVisitor",
                "defaultvalue":"true"
            },
            {
                "id":"remove_duplicate_relation_members_visitor",
                "elem_type":"checkbox",
                "description":"Remove all duplicate relation members in a relation.",
                "name":"Remove Duplicate Relation Members",
                "hoot_val":"RemoveDuplicateRelationMembersVisitor",
                "defaultvalue":"true"
            },
            {
                "id":"relation_circular_ref_remover",
                "elem_type":"checkbox",
                "description":"Remove all circular references within relations.",
                "name":"Remove Relation Circular References",
                "hoot_val":"RelationCircularRefRemover",
                "defaultvalue":"true"
            },
            {
                "id":"remove_empty_relations",
                "elem_type":"checkbox",
                "description":"Remove all relations with no members.",
                "name":"Remove Empty Relations",
                "hoot_val":"RemoveEmptyRelationsOp",
                "defaultvalue":"true"
            },
            {
                "id":"remove_duplicate_area_visitor",
                "elem_type":"checkbox",
                "description":"Remove any area elements that are essentially the same.",
                "name":"Remove Duplicate Areas",
                "hoot_val":"RemoveDuplicateAreasVisitor",
                "defaultvalue":"true"
            },
            {
                "id":"no_information_element_remover",
                "elem_type":"checkbox",
                "description":"Remove any elements that don't have any tags with information. (E.g. only contains UUID and source, but not FCODE equivalent or other informative tags).",
                "name":"Remove Elements With No Information",
                "hoot_val":"NoInformationElementRemover",
                "defaultvalue":"true"
            },
            {
                "id":"corner_splitter",
                "elem_type":"checkbox",
                "description":"Split roads at sharp corners.",
                "name":"Split Sharp Road Corners",
                "hoot_val":"HighwayCornerSplitter",
                "defaultvalue":"true"
            },
            {
                "id":"implicit_type_tagger",
                "elem_type":"checkbox",
                "description":"Add missing type tags to input data implied from the feature name",
                "name":"Add Missing Type Tags",
                "hoot_val":"ImplicitPoiPolygonTypeTagger",
                "defaultvalue":"false"
            }
        ]
    },
    {
        "id":"hoot_rubber_sheeting_options",
        "elem_type":"group",
        "dependencies":[
            {
                "id":"map_cleaner_transforms",
                "append":{
                    "id":"RubberSheet",
                    "isDefault":"true",
                    "description":"Enable rubber sheet",
                    "dependent":"hoot_enable_rubber_sheeting",
                    "name":"Rubber Sheet",
                    "hoot_val":"RubberSheet",
                    "hoot_key":"map.cleaner.transforms"
                }
            }
        ],
        "description":"Hootenanny rubber sheeting options",
        "name":"Rubber Sheeting Options",
        "members":[
            {
                "id":"hoot_enable_rubber_sheeting_options",
                "elem_type":"checkbox",
                "description":"Enable rubber sheeting options",
                "name":"Enabled",
                "defaultvalue":"true",
                "onchange":"true"
            },
            {
                "id":"rubber_sheet_ref",
                "elem_type":"checkbox",
                "description":"If this configuration setting is set to true then the first layer is treated as the reference layer and will not be moved. If set to false the two layers will be moved towards each other. The weighting is determined based on the circular error.",
                "name":"Don't Move Reference Layer",
                "defaultvalue":"true",
                "hoot_key":"rubber.sheet.ref"
            },
            {
                "id":"rubber_sheet_fail_when_min_tie_points_not_found",
                "elem_type":"checkbox",
                "description":"If set to true, rubber sheeting will return an error if less than rubber.sheet.minimum.ties tie points are found.  Otherwise, a warning will be logged and rubber sheeting will be skipped.",
                "name":"Fail When Minimum Tie Points Are Not Found",
                "defaultvalue":"false",
                "hoot_key":"rubber.sheet.fail.when.minimum.tie.points.not.found"
            },
            {
                "id":"rubber_sheet_log_missing_requirements_as_warning",
                "elem_type":"checkbox",
                "description":"From the UI we always want to log this as warning.  e.g. min tie points not found",
                "name":"Log Missing Requirements As Warning",
                "required":"true",
                "defaultvalue":"true",
                "hoot_key":"rubber.sheet.log.missing.requirements.as.warning"
            },
            {
                "id":"rubber_sheet_minimum_ties",
                "minvalue":"0",
                "elem_type":"int",
                "description":"Sets the minimum number of tie points that will be used when calculating a rubber sheeting solution.",
                "maxvalue":"",
                "name":"Minimum Ties Required",
                "defaultvalue":"4",
                "hoot_key":"rubber.sheet.minimum.ties"
            },
            {
                "id":"rubber_sheet_max_interpolator_iterations",
                "minvalue":"1",
                "elem_type":"int",
                "description":"The maximum number of interpolation optimization iterations, per optimization loop, an interpolator is allowed to run during rubber sheeting.  Use -1 for no iteration limit.  Not supported by all interpolators.  Can prevent runaway optimizations with some interpolators.  Lower values may result in the selection of a suboptimal interpolator.",
                "maxvalue":"",
                "name":"Max Interpolator Iterations",
                "defaultvalue":"200",
                "hoot_key":"rubber.sheet.max.interpolator.iterations"
            }
        ]
    },
    {
        "id":"hoot_general_conflation_options",
        "elem_type":"group",
        "description":"Hootenanny general conflation options",
        "name":"General Conflation Options",
        "members":[
            {
            	"id":"add_review_tags_to_features",
                "elem_type":"bool",
                "defaultvalue":"false",
                "description":"If true, not only will review relations receive the hoot:review:needs tag, the features involved in the review will receive them as well.",
                "name":"Add Review Tags To Individual Features",
                "hoot_key":"add.review.tags.to.features"
            },
            {
                "id":"auto_correct_options",
                "elem_type":"bool",
                "defaultvalue":"true",
                "required":"true",
                "description":"Temporary setting that addresses some Hootenanny iD Editor UI bugs.  See MatchFactory::_tempFixDefaults() for more info.",
                "name":"Auto Correct Options",
                "hoot_key":"autocorrect.options"
            },
            {
                "id":"element_cache_size_node",
                "minvalue":"0",
                "elem_type":"int",
                "description":"Size of the memory cache used when streaming I/O is used with nodes.",
                "name":"Cache Size For Nodes",
                "maxvalue":"",
                "defaultvalue":"2000000",
                "hoot_key":"element.cache.size.node"
            },
            {
                "id":"element_cache_size_relation",
                "minvalue":"0",
                "elem_type":"int",
                "description":"Size of the memory cache used when streaming I/O is used with relations.",
                "name":"Cache Size For Relations",
                "maxvalue":"",
                "defaultvalue":"200000",
                "hoot_key":"element.cache.size.relation"
            },
            {
                "id":"element_cache_size_way",
                "minvalue":"0",
                "elem_type":"int",
                "description":"Size of the memory cache used when streaming I/O is used with ways.",
                "name":"Cache Size For Ways",
                "maxvalue":"",
                "defaultvalue":"200000",
                "hoot_key":"element.cache.size.way"
            },
            {
                "id":"duplicate_name_case_sensitive",
                "elem_type":"checkbox",
                "hoot_key":"duplicate.name.case.sensitive",
                "description":"If checked, the duplicate name remover will only remove duplicate names when their case also matches; Will ignore case when removing otherwise",
                "name":"Duplicate Name Remover Case Sensitive",
                "defaultvalue":"true"
            },
            {
            	"id":"edge_distance_extractor_spacing",
                "minvalue":"0.01",
                "elem_type":"double",
                "description":"The spacing used by the EdgeDistanceExtractor.  Units in meters.",
                "maxvalue":"",
                "name":"Edge Distance Extractor Spacing",
                "defaultvalue":"5.0",
                "hoot_key":"edge.distance.extractor.spacing"
            },
            {
                "id":"frechet_distance",
                "elem_type":"checkplus",
                "override":{
                    "elem_type":"checkplus"
                },
                "description":"Frechet Distance",
                "name":"Frechet Distance Subline Matcher",
                "onchange":"true",
                "defaultvalue":"false",
                "members":[
                    {
                        "id":"frechet_way_subline_matcher",
                        "elem_type":"string",
                        "description":"The way subline matcher to use when determining matching sublines.",
                        "name":"Way Subline Matcher (Frechet)",
                        "defaultvalue":"FrechetSublineMatcher",
                        "override":{
                            "defaultvalue":"FrechetSublineMatcher"
                        },
                        "hoot_key":"way.subline.matcher",
                        "required":"true"
                    }
                ]
            },
            {
            	"id":"token_keep_non_words",
                "elem_type":"bool",
                "defaultvalue":"false",
                "description":"This does a rudimentary check to see if the string contains any letters/numbers. If the string doesn't contain any letters or numbers then it will be dropped.",
                "name":"Keep Non Word Tokens",
                "hoot_key":"token.keep.non.words"
            },
            {
            	"id":"levenshtein_distance_alpha",
                "minvalue":"0.01",
                "elem_type":"double",
                "description":"Raise the Levenshtein score to this power before returning this result. If alpha is greater than 1 then this makes low scores even lower. Valid values are greater than 0.",
                "maxvalue":"",
                "name":"Levenshtein Distance Alpha",
                "defaultvalue":"1.15",
                "hoot_key":"levenshtein.distance.alpha"
            },
            {
            	"id":"duplicate_node_remover_distance_threshold",
                "minvalue":"0.01",
                "elem_type":"double",
                "description":"When merging nodes during convert, determines what tolerance should be used for deciding two nodes are identical. Units in meters and defaults to 1.0m.",
                "maxvalue":"",
                "name":"Merge Nearby Nodes Distance",
                "defaultvalue":"1.0",
                "hoot_key":"duplicate.node.remover.distance.threshold"
            },
            {
            	"id":"token_min_size",
                "minvalue":"0.0",
                "elem_type":"double",
                "description":"This is the minimum string size that the string tokenizer should accept as a token. If the string length is less than this value, then it will not be accepted. Set the value to 0 if you want to accept all strings.  This setting primarily applies to string comparison functions and will eliminate comparing very short strings.",
                "maxvalue":"",
                "name":"Minimum String Token Size",
                "defaultvalue":"3.0",
                "hoot_key":"token.min.size"
            },
	       {
            	"id":"node_matcher_strictness",
                "minvalue":"0.0",
                "elem_type":"double",
                "description":"Determines how strictly the angle should be considered when calculating intersection tie points for rubber sheeting. A value of 0 will ignore angle entirely. Large will make the angle comparison more strict.",
                "maxvalue":"",
                "name":"Node Matcher Strictness",
                "defaultvalue":"2.0",
                "hoot_key":"node.matcher.strictness"
            },
            {
                "id":"ogr_esri_fcsubtype",
                "elem_type":"checkbox",
                "description":"Add the ESRI specific FCSUBTYPE field to the output",
                "name":"OGR Esri FCSubtype",
                "defaultvalue":"true",
                "hoot_key":"ogr.esri.fcsubtype"
            },
            {
                "id":"ogr_thematic_structure",
                "elem_type":"checkbox",
                "description":"Export data in Thematic Groups (TransportationGroundCrv, StructurePnt etc) instead of one FCODE per file/layer (ROAD_L, BUILDING_P etc).",
                "name":"OGR Thematic Structure",
                "defaultvalue":"true",
                "hoot_key":"ogr.thematic.structure"
            },
            {
            	"id":"language_translation_string_distance_tokenize",
                "elem_type":"bool",
                "defaultvalue":"true",
                "description":"Set to true if the strings should be tokenized (split into words) before translating the values.",
                "name":"Tokenize Strings When Translating",
                "hoot_key":"language.translation.string.distance.tokenize"
            },
            {
                "id":"conflate_use_data_source_ids_1",
                "elem_type":"bool",
                "defaultvalue":"false",
                "description":"Determines whether the reader used by the conflate command to read the first input dataset will use the element ID's specified by the input datasets (true) or use internal ID management for the inputs (false).",
                "name":"Preserve element ids from the Reference layer during conflation",
                "hoot_key":"conflate.use.data.source.ids.1"
            },
            {
                "id":"conflate_use_data_source_ids_2",
                "elem_type":"bool",
                "defaultvalue":"false",
                "description":"Determines whether the reader used by the conflate command to read the second input dataset will use the element ID's specified by the input datasets (true) or use internal ID management for the inputs (false).",
                "name":"Preserve element ids from the Secondary layer during conflation",
                "hoot_key":"conflate.use.data.source.ids.2"
            },
	    {
            	"id":"weighted_metric_distance_extractor_search_radius",
                "minvalue":"-1.0",
                "elem_type":"double",
                "description":"The search radius used by the WeightedMetricDistanceExtractor.  Units in meters.  Defaults to a value computed from the circular error for each way being examined.",
                "maxvalue":"",
                "name":"Weighted Metric Distance Extractor Search Radius",
                "defaultvalue":"-1.0",
                "hoot_key":"weighted.metric.distance.extractor.search.radius"
            },
            {
                "id":"unify_optimizer_time_limit",
                "minvalue":"-1",
                "elem_type":"int",
                "description":"The maximum amount of time in seconds to wait for the optimizer to complete. A value of -1 makes the time limit unlimited. If this value is set to something other than -1 your conflation results may change between multiple runs. Especially if the machine Hoot is running on is under heavy load. If the \"CM Score:\" value is changing between runs and GLPK isn't finding an optimal solution then this is likely causing different output. Just because the output is changing doesn't mean it is wrong, but this can be problematic if you're doing testing or expecting repeatable output for other",
                "maxvalue":"",
                "name":"Unifying Optimizer Time Limit",
                "defaultvalue":"30",
                "hoot_key":"unify.optimizer.time.limit"
            }
        ]
    },
    {
        "id":"hoot_road_options",
        "elem_type":"group",
        "description":"Hootenanny road options",
        "name":"Road Options",
        "members":[
            {
                "id":"hoot_enable_road_options",
                "elem_type":"checkbox",
                "description":"Enable road options",
                "name":"Enabled",
                "defaultvalue":"true",
                "onchange":"true"
            },
            {
            	"id":"search_radius_highway",
                "minvalue":"-1",
                "elem_type":"double",
                "description":"The search radius to use when conflating highways. If two features are within the search radius then they will be considered for conflation. If the value is -1 then the circular error will be used to calculate an appropriate search radius.",
                "maxvalue":"",
                "name":"Road Search Radius",
                "defaultvalue":"-1",
                "override":{
                	"defaultvalue":"-1"
                },
                "hoot_key":"search.radius.highway"
            },
            {
            	"id":"way_merger_min_split_size",
                "minvalue":"0.01",
                "elem_type":"double",
                "description":"The minimum size that a way should be split into for merging. Units in meters.",
                "maxvalue":"",
                "name":"Way Merger Minimum Split Size",
                "defaultvalue":"5",
                "hoot_key":"way.merger.min.split.size"
            },
            {
                "id":"hoot_road_opt_engine",
                "elem_type":"list",
                "description":"A list of road engines",
                "name":"Engines",
                "defaultvalue":"Network",
                "onchange":"true",
                "members":[
                    {
                        "id":"hoot_road_opt_engine_unify",
                        "description":"A non-greedy road conflation algorithm which uses a random-forest model for classification",
                        "name":"Unify",
                        "members":[
                            {
                                "id":"conflate_match_highway_classifier",
                                "elem_type":"string",
                                "description":"The highway match classifier to use. This should only be used for testing and debugging.",
                                "name":"Conflate Match Highway Classifier",
                                "required":"true",
                                "defaultvalue":"HighwayExpertClassifier",
                                "hoot_key":"conflate.match.highway.classifier"
                            },
                            {
                                "id":"road_match_creator",
                                "elem_type":"string",
                                "description":"List of MatchCreators to use during conflation. This can modify what features will be conflated (e.g. buildings, roads, etc.).",
                                "name":"Match Creator",
                                "required":"true",
                                "defaultvalue":"HighwayMatchCreator",
                                "override":{
                                    "defaultvalue":"HighwayMatchCreator"
                                },
                                "hoot_key":"match.creators"
                            },
                            {
                                "id":"road_merger_creator",
                                "elem_type":"string",
                                "description":"List of MergerCreators to use during conflation. This can modify what features will be conflated (e.g. buildings, roads, etc.).",
                                "name":"Merger Creator",
                                "required":"true",
                                "defaultvalue":"HighwayMergerCreator",
                                "override":{
                                    "defaultvalue":"HighwayMergerCreator"
                                },
                                "hoot_key":"merger.creators"
                            },
                            {
                                "id":"highway_matcher_heading_delta",
                                "minvalue":"0.0",
                                "elem_type":"double",
                                "description":"The distance around a point on a way to look when calculating the heading. A larger value will smooth out the heading values on a line. A smaller value will make the heading values correspond directly to the heading on the way at that point. This is primarily used in subline matching. Values are in meters.",
                                "maxvalue":"360.0",
                                "name":"Highway Matcher Heading Delta",
                                "defaultvalue":"5.0",
                                "hoot_key":"highway.matcher.heading.delta"
                            },
                            {
                                "id":"highway_matcher_max_angle",
                                "minvalue":"0.0",
                                "elem_type":"double",
                                "description":"Sets that maximum angle that is still considered a highway match. Units in degrees.",
                                "maxvalue":"360.0",
                                "name":"Highway Matcher Max Angle",
                                "defaultvalue":"60",
                                "hoot_key":"highway.matcher.max.angle"
                            },
                            {
                		"id":"highway_max_enum_diff",
                		"minvalue":"0.01",
                		"elem_type":"double",
                		"description":"If two highways have significantly different enumerated types then they will not be considered for match. For example: highway=primary vs highway=secondary has a diff of 0.2.  highway=primary vs highway=footway has a diff of 0.67.",
                		"maxvalue":"1.0",
                		"name":"Highway Max Enum Diff",
                		"defaultvalue":"0.6",
                		"hoot_key":"highway.max.enum.diff"
           		    }
                        ]
                    },
                    {
                        "id":"hoot_road_opt_engine_network",
                        "description":"A road conflation algorithm based on graph operations treating the data as a network",
                        "name":"Network",
                        "members":[
                            {
                                "id":"network_match_creator",
                                "elem_type":"string",
                                "description":"List of MatchCreators to use during conflation. This can modify what features will be conflated (e.g. buildings, roads, etc.).",
                                "name":"Match Creator",
                                "required":"true",
                                "defaultvalue":"NetworkMatchCreator",
                                "override":{
                                    "defaultvalue":"NetworkMatchCreator"
                                },
                                "hoot_key":"match.creators"
                            },
                            {
                                "id":"network_merger_creator",
                                "elem_type":"string",
                                "description":"List of MergerCreators to use during conflation. This can modify what features will be conflated (e.g. buildings, roads, etc.).",
                                "name":"Merger Creator",
                                "required":"true",
                                "defaultvalue":"NetworkMergerCreator",
                                "override":{
                                    "defaultvalue":"NetworkMergerCreator"
                                },
                                "hoot_key":"merger.creators"
                            },
                            {
                                "id":"network_matcher",
                                "elem_type":"string",
                                "description":"The network matcher to use during conflation. This option represents different algorithms used for scoring matches.",
                                "name":"Network Matcher",
                                "required":"true",
                                "defaultvalue":"ConflictsNetworkMatcher",
                                "override":{
                                    "defaultvalue":"ConflictsNetworkMatcher"
                                },
                                "hoot_key":"network.matcher"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "id":"hoot_differential_road_options",
        "elem_type":"group",
        "description":"Hootenanny Differential Conflation Options",
        "name":"Differential Conflation Options",
        "members":[
            {
            	"id":"differential_snap_unconnected_features",
                "elem_type":"bool",
                "defaultvalue":"false",
                "description":"If true, when running Differential Conflation the Unconnected Way Snapper will snap unconnected secondary feature endpoint nodes to the nearest reference feature.",
                "name":"Snap Unconnected Roads",
                "hoot_key":"differential.snap.unconnected.features"
            },
            {
            	"id":"differential_road_remove_reference_data",
                "elem_type":"bool",
                "defaultvalue":"true",
                "description":"If false, when running Differential Conflation the reference elements will not be dropped from the output.",
                "name":"Remove Reference Data",
                "hoot_key":"differential.remove.reference.data"
            },
            {
            	"id":"differential_feature_snap_tolerance",
                "elem_type":"double",
                "description":"Maximum distance, in meters, allowed between an unconnected linear feature and a neighboring linear feature for the unconnected feature to be snapped to the closest section of the neighboring linear feature.",
                "name":"Road Snap Tolerance",
                "defaultvalue":"5.0",
                "minvalue":"0.01",
                "maxvalue":"50.0",
                "hoot_key":"snap.unconnected.ways.snap.tolerance"
            },
            {
            	"id":"differential_feature_snap_use_existing_feature_nodes",
                "elem_type":"bool",
                "defaultvalue":"true",
                "description":"If true, when feature nodes are snapped to neighboring features, Hootenanny will attempt to snap to existing feature nodes on instead of adding new ones.",
                "name":"Use Existing Road Nodes When Snapping Roads",
                "hoot_key":"snap.unconnected.ways.use.existing.way.nodes"
            },
            {
            	"id":"differential_feature_snap_existing_feature_node_tolerance",
                "elem_type":"double",
                "description":"Maximum distance, in meters, allowed between an unconnected feature and a neighboring feature for the feature node to be snapped directly to the existing feature node.",
                "name":"Name Score Threshold",
                "defaultvalue":"0.5",
                "minvalue":"0.01",
                "maxvalue":"50.0",
                "hoot_key":"snap.unconnected.ways.existing.way.node.tolerance"
            }
        ]
    },
    {
        "id":"hoot_area_options",
        "elem_type":"group",
        "description":"Hootenanny area options",
        "name":"Area Options",
        "members":[
            {
                "id":"hoot_enable_area_options",
                "elem_type":"checkbox",
                "description":"Enable area options",
                "name":"Enabled",
                "defaultvalue":"true",
                "onchange":"true"
            },
            {
                "id":"area_match_creator",
                "elem_type":"string",
                "description":"",
                "name":"Match Creator",
                "required":"true",
                "defaultvalue":"ScriptMatchCreator,Area.js",
                "override":{
                    "defaultvalue":"ScriptMatchCreator,Area.js"
                },
                "hoot_key":"match.creators",
                "required":"true"
            },
            {
                "id":"area_merger_creator",
                "elem_type":"string",
                "description":"",
                "name":"Merger Creator",
                "required":"true",
                "defaultvalue":"ScriptMergerCreator",
                "override":{
                    "defaultvalue":"ScriptMergerCreator"
                },
                "hoot_key":"merger.creators",
                "required":"true"
            }
        ]
    },
    {
        "id":"hoot_building_options",
        "elem_type":"group",
        "description":"Hootenanny building options",
        "name":"Building Options",
        "members":[
            {
                "id":"hoot_enable_building_options",
                "elem_type":"checkbox",
                "description":"Enable building options",
                "name":"Enabled",
                "defaultvalue":"true",
                "onchange":"true"
            },
            {
                "id":"building_match_creator",
                "elem_type":"string",
                "description":"List of MatchCreators to use during conflation. This can modify what features will be conflated (e.g. buildings, roads, etc.).",
                "name":"Match Creator",
                "required":"true",
                "defaultvalue":"BuildingMatchCreator",
                "override":{
                    "defaultvalue":"BuildingMatchCreator"
                },
                "hoot_key":"match.creators",
                "required":"true"
            },
            {
                "id":"building_merger_creator",
                "elem_type":"string",
                "description":"List of MergerCreators to use during conflation. This can modify what features will be conflated (e.g. buildings, roads, etc.).",
                "name":"Merger Creator",
                "required":"true",
                "defaultvalue":"BuildingMergerCreator",
                "override":{
                    "defaultvalue":"BuildingMergerCreator"
                },
                "hoot_key":"merger.creators",
                "required":"true"
            },
            {
        	"id":"building_date_format",
        	"elem_type":"string",
        	"description":"Date format string used by the building date tag value.  See QDateTime::fromString for more details.",
        	"name":"Date Format",
        	"defaultvalue":"yyyy-MM-ddTHH:mm",
        	"hoot_key":"building.date.format",
        	"onchange":"true"
    	    },
            {
        	"id":"building_date_tag_key",
        	"elem_type":"string",
        	"description":"Tag key used by the building.review.if.secondary.newer configuration option.",
        	"name":"Date Tag Key",
        	"defaultvalue":"source:date",
        	"hoot_key":"building.date.tag.key",
        	"onchange":"true"
    	    },
            {
              "id": "building_force_contained_match",
              "elem_type": "bool",
              "description": "If true, a building pair has been flagged for review, and one member of the pair is contained completely inside the other, the pair will be matched instead.",
              "name": "Always atch When One Building Is Completely Contained Inside Another",
              "defaultvalue": "false",
              "hoot_key": "building.force.contained.match"
            },
            {
            	"id":"building_keep_more_complex_geometry_when_auto_merging",
                "elem_type":"bool",
                "defaultvalue":"true",
                "description":"If true, when buildings are auto-merged during conflation the geometry of the more complex building is the one that is kept.  If false or the buildings are equally complex, then the geometry of the first building in the pair passed to the Building Merger is the geometry kept.  This does not apply to feature merging done during the manual review process.",
                "name":"Keep More Complex Geometry When Auto Merging",
                "hoot_key":"building.keep.more.complex.geometry.when.auto.merging"
            },
            {
              "id":"building_match_threshold",
              "elem_type":"double",
              "description":"The threshold at which a match is called a match for buildings. The higher the value, the more strict the matching becomes.",
              "defaultvalue":"0.6",
              "minvalue":"0.01",
              "maxvalue":"1.0",
              "hoot_key":"building.match.threshold"
            },
            {
            	"id":"building_merge_many_to_many_matches",
                "elem_type":"bool",
                "defaultvalue":"false",
                "description":"If false, many to many building matches will result in a review. If true, they will all be merged together when matched.",
                "name":"Merge Many to Many Matches",
                "hoot_key":"building.merge.many.to.many.matches"
            },
            {
            	"id":"building_review_if_secondary_newer",
                "elem_type":"bool",
                "defaultvalue":"false",
                "description":"If true, any buildings in the secondary layer will be automatically reviewed against potentially matching features in the reference layer if they are marked with a more recent date than that of the reference feature.",
                "name":"Review If Secondary Layer Building Newer",
                "hoot_key":"building.review.if.secondary.newer"
            },
            {
            	"id":"building_review_matches_other_than_one_to_one",
                "elem_type":"bool",
                "defaultvalue":"false",
                "description":"If true, any building matches other than 1:1 matches are automatically marked for review.",
                "name":"Review Non 1:1 Building Matches",
                "hoot_key":"building.review.matches.other.than.one.to.one"
            }
        ]
    },
    {
        "id":"hoot_poi_options",
        "elem_type":"group",
        "description":"Hootenanny POI conflation options",
        "name":"POI Options",
        "members":[
            {
                "id":"hoot_enable_poi_options",
                "elem_type":"checkbox",
                "description":"Enable POI options",
                "name":"Enabled",
                "defaultvalue":"true",
                "onchange":"true"
            },
            {
            	"id":"poi_ignore_type_if_name_present",
                "elem_type":"bool",
                "defaultvalue":"false",
                "description":"If true, POI to POI conflation will ignore the types of the features being compared completely as long as those being compared have a populated name field.",
                "name":"Ignore Type If Name Present",
                "hoot_key":"poi.ignore.type.if.name.present"
            },
            {
            	"id":"poi_match_creator_unifying",
                "elem_type":"string",
                "description":"",
                "name":"Match Creator",
                "required":"true",
                "defaultvalue":"ScriptMatchCreator,Poi.js",
                "override":{
                	"defaultvalue":"ScriptMatchCreator,Poi.js"
                },
            	"hoot_key":"match.creators"
            },
            {
            	"id":"poi_merger_creator_unifying",
                "elem_type":"string",
                "description":"",
                "name":"Merger Creator",
                "required":"true",
                "defaultvalue":"ScriptMergerCreator",
                "override":{
                	"defaultvalue":"ScriptMergerCreator"
                },
                "hoot_key":"merger.creators"
            }
        ]
    },
    {
        "id":"hoot_poi_poly_options",
        "elem_type":"group",
        "description":"Hootenanny POI to Polygon conflation options",
        "name":"POI to Polygon Options",
        "members":[
            {
                "id":"hoot_enable_poi_poly_options",
                "elem_type":"checkbox",
                "description":"Enable POI to Polygon options",
                "name":"Enabled",
                "defaultvalue":"true",
                "onchange":"true"
            },
            {
            	"id":"poi_poly_match_creator_unifying",
                "elem_type":"string",
                "description":"List of MatchCreators to use during conflation. This can modify what features will be conflated (e.g. buildings, roads, etc.).",
		"name":"Match Creator",
                "required":"true",
                "defaultvalue":"PoiPolygonMatchCreator",
                "override":{
                	"defaultvalue":"PoiPolygonMatchCreator"
                	},
                "hoot_key":"match.creators"
            },
            {
            	"id":"poi_poly_merger_creator_unifying",
                "elem_type":"string",
                "description":"List of MergerCreators to use during conflation. This can modify what features will be conflated (e.g. buildings, roads, etc.).",
                "name":"Merger Creator",
                "required":"true",
                "defaultvalue":"PoiPolygonMergerCreator",
                "override":{
                	"defaultvalue":"PoiPolygonMergerCreator"
                },
                "hoot_key":"merger.creators"
            },
            {
        	"id":"poipolygon_address_additional_tag_keys",
        	"elem_type":"string",
        	"description":"By default, POI/Polygon conflation examines standard OSM tags for address comparisons (see the addressTagKeys file).  You can expand the tag keys searched by populating this list. From the command line, separate list items with a semicolon and surround the entire list in double quotes.",
        	"name":"Address Additional Tag Keys",
        	"defaultvalue":"",
        	"hoot_key":"address.additional.tag.keys",
        	"onchange":"true"
    	    },
            {
        	"id":"poipolygon_address_allow_lenient_house_number_matching",
        	"elem_type":"bool",
        	"defaultvalue":"true",
        	"description":"If true, POI/Polygon conflation will allow house number subletter mismatches for the addresses with the same house number.  e.g. when enabled, 23a Elm Street matches 23 Elm Street",
        	"name":"Allow Lenient House Number Matching",
        	"hoot_key":"address.allow.lenient.house.number.matching"
    	    },
            {
        	"id":"address_match_enabled",
        	"elem_type":"bool",
        	"defaultvalue":"true",
        	"description":"If true, conflators that support address matching will compare addresses as one of the criteria for matching features.  If the data being conflated is known to have poor address data, disabling this option may speed up conflation runtime performance.",
        	"name":"Address Match Enabled",
        	"hoot_key":"address.match.enabled"
    	    },
            {
        	"id":"poipolygon_allow_cross_conflation_merging",
        	"elem_type":"bool",
        	"defaultvalue":"false",
        	"description":"If false, when a match found by Building Conflation involves the same feature in a match found by POI to Polygon Conflation, a review will be generated. If true, then that situation will result in a merge between all features involved in the Building and POI to Polygon conflation matches.",
        	"name":"Allow Cross Conflation Merging",
        	"hoot_key":"poi.polygon.allow.cross.conflation.merging"
    	    },
            {
        	"id":"poipolygon_auto_merge_many_poi_to_one_poly_matches",
        	"elem_type":"bool",
        	"defaultvalue":"false",
        	"description":"If true, instances where multiple POIs were matched to a single polygon will result in all of those POIs being automatically merged into the polygon.  If false, then each matched POI will generate a review against the polygon instead.",
		"name":"Merge Many POI to Single Polygon Matches",
        	"hoot_key":"poi.polygon.auto.merge.many.poi.to.one.poly.matches"
    	    },
            {
        	"id":"poipolygon_disable_same_source_conflation",
        	"elem_type":"bool",
        	"defaultvalue":"false",
        	"description":"If true, POI to polygon conflation will not attempt to conflate two features with the same source tag value.  e.g. both have 'source=osm' tag  The source tag key is specified by poi.polygon.source.tag.key.  How strictly the source tag key must be matched is controlled by poi.polygon.disable.same.source.conflation.match.tag.key.prefix.only.  This setting is useful when you have a data layer where data has been collected as both POIs and polygons for the same source and you never want the two source to be conflated together.",
        	"name":"Disable Same Source Conflation",
        	"hoot_key":"poi.polygon.disable.same.source.conflation"
    	    },
            {
        	"id":"poipolygon_disable_same_source_conflation_match_tag_key_prefix_only",
        	"elem_type":"bool",
        	"defaultvalue":"true",
        	"description":"If set to false and poi.polygon.disable.same.source.conflation is set to true, POI to polygon conflation will disable conflation only between features who have the exact same source tag value.  e.g. both have 'source=osm' tag  If set to true and poi.polygon.disable.same.source.conflation is set to true, then the tag matcher is less strict and will attempt to match the prefix of the source tag value when delimited by a colon.  e.g. 'source=mgcp:buildp_clip;osm' will match 'source=mgcp:builda_clip;osm' since both tag values begin with 'mgcp:'.",
        	"name":"Disable Same Source Conflation Match Tag Key Prefix Only",
        	"hoot_key":"poi.polygon.disable.same.source.conflation.match.tag.key.prefix.only"
    	    },
            {
        	"id":"poipolygon_keep_closest_matches_only",
        	"elem_type":"bool",
        	"defaultvalue":"false",
        	"description":"If this setting is true, POI to Polygon conflation will attempt to match the closest feature pairs only.  The conflation will not match additional features at greater distances, even if they are within the match distance threshold.  Multiple features matches are still possible in the case of exact distance ties.  If this setting is false, then multiple POIs found within the match distance threshold of a polygon are treated as reviews.",
                "name":"Keep Closest Matches Only",
        	"hoot_key":"poi.polygon.keep.closest.matches.only"
    	    },
            {
        	"id":"poipolygon_match_distance_threshold",
        	"elem_type":"int",
        	"description":"The maximum distance, in meters, between a POI and a polygon where they can still be considered a match based on distance criteria only.",
        	"name":"Match Distance Threshold",
        	"defaultvalue":"5",
        	"minvalue":"0",
        	"maxvalue":"",
        	"hoot_key":"poi.polygon.match.distance.threshold"
    	    },
            {
        	"id":"poipolygon_match_evidence_threshold",
        	"elem_type":"int",
        	"description":"The minimum evidence score at which a POI will be matched to a polygon.  Valid values are 1 to 4.  If an evidence score for a feature pair falls below this value, the relationship between the features will be classified as a review or miss, depending on the value of 'poi.polygon.review.evidence.threshold'.  Generally, this setting should not be changed except when working with specific POI/Polygon conflation use cases that require it.",
        	"name":"Match Evidence Threshold",
        	"defaultvalue":"3",
        	"minvalue":"1",
        	"maxvalue":"4",
        	"hoot_key":"poi.polygon.match.evidence.threshold"
    	    },
            {
            	"id":"poipolygon_name_score_threshold",
                "elem_type":"double",
                "description":"The minimum similarity the name scores of two features can have and be considered a name match, with 0.0 being the least similar and 1.0 being the most similar (-1.0 if there are no names present (null).",
                "name":"Name Score Threshold",
                "defaultvalue":"0.8",
                "minvalue":"0.01",
                "maxvalue":"1.0",
                "hoot_key":"poi.polygon.name.score.threshold"
            },
            {
        	"id":"poipolygon_phone_number_additional_tag_keys",
        	"elem_type":"string",
        	"description":"By default, POI/Polygon conflation examines all tags with keys containing the text 'phone' for phone number comparisons.  You can expand the tag keys searched by populating this list. From the command line, separate list items with a semicolon and surround the entire list in double quotes.",
        	"name":"Phone Number Additional Tag Keys",
        	"defaultvalue":"",
        	"hoot_key":"phone.number.additional.tag.keys",
        	"onchange":"true"
    	    },
            {
        	"id":"poipolygon_phone_number_match_enabled",
        	"elem_type":"bool",
        	"defaultvalue":"true",
        	"description":"If true, POI/Polygon conflation will compare phone number as one of the criteria for matching features.  If the data being conflated is known to have poor telephone number data, disabling this option may speed up conflation runtime performance.",
        	"name":"Phone Number Match Enabled",
        	"hoot_key":"poi.polygon.phone.number.match.enabled"
    	    },
            {
        	"id":"poipolygon_phone_number_region_code",
        	"elem_type":"string",
        	"description":"Optional geographical region code used when comparing phone numbers.   See: http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html  Specifying a region code, if known for the input data, may increase phone number matching accuracy but may also have runtime performance implications.",
        	"name":"Phone Number Region Code",
        	"defaultvalue":"",
        	"hoot_key":"phone.number.region.code",
        	"onchange":"true"
    	    },
            {
        	"id":"poipolygon_phone_number_search_in_text",
        	"elem_type":"bool",
        	"defaultvalue":"false",
        	"description":"If true, POI/Polygon conflation will attempt to search for phone numbers within tag value text that may contain things other than phone numbers.  If false, the conflation will assume the tag value is a phone number and will not search within it.  phone.number.region.code must be set to a valid region code when enabling this option.  Enabling this option may have runtime performance implications.",
        	"name":"Phone Number Search In Text",
        	"hoot_key":"phone.number.search.in.text"
    	    },
            {
        	"id":"poipolygon_promote_points_with_addresses_to_pois",
        	"elem_type":"bool",
        	"defaultvalue":"false",
        	"description":"If true, POI to polygon conflation will classify all points with OSM address tags as POIs even if they do not have specific type tags.",
        	"name":"Promote Points With Addresses to POIs",
        	"hoot_key":"poi.polygon.promote.points.with.addresses.to.pois"
    	    },
            {
        	"id":"poipolygon_additional_search_distance",
        	"elem_type":"int",
        	"description":"The maximum distance, in meters, combined with the circular error of the features being compared, the total of which allows the features to still be considered a match based on distance criteria only.",
        	"name":"Review Distance Threshold",
        	"defaultvalue":"125",
        	"minvalue":"0",
        	"maxvalue":"",
        	"hoot_key":"poi.polygon.additional.search.distance"
    	    },
            {
        	"id":"poipolygon_review_evidence_threshold",
        	"elem_type":"int",
        	"description":"The minimum evidence score at which a POI will be reviewed against a polygon, if the evidence score does not meet the threshold defined by 'poi.polygon.match.evidence.threshold'. Valid values are 0 to 3. If an evidence score for a feature pair falls below this value, the relationship between the features will be classified as a miss. If the value is set to 0, all feature pairs which did not match will be reviewed. If the value is set greater than or equal to 'poi.polygon.match.evidence.threshold', an error will occur. Generally, this setting should not be changed except when working with specific POI/Polygon conflation use cases that require it.",
        	"name":"Review Evidence Threshold",
        	"defaultvalue":"1",
        	"minvalue":"0",
        	"maxvalue":"3",
        	"hoot_key":"poi.polygon.review.evidence.threshold"
    	    },
            {
        	"id":"poipolygon_review_if_matched_types",
        	"elem_type":"string",
        	"description":"List of key value pairs in the format 'key=value' or  'key,value' (UI only) for features to always review if marked as matches with POI to polygon conflation.  Delimit the individual types with ';'.  e.g. 'amenity=school;shop=mall' or 'amenity,school;shop,mall'  Also, when specifying the list from the command line, surround the entire value string in double quotes.",
        	"name":"Review If Types Match",
        	"defaultvalue":"",
        	"hoot_key":"poi.polygon.review.if.matched.types",
        	"onchange":"true"
    	    },
            {
        	"id":"poipolygon_review_multiuse_buildings",
        	"elem_type":"bool",
        	"defaultvalue":"false",
        	"description":"If true, POI to polygon conflation always mark matches between POIs and polygons where multi-use buildings are present.  See the user documentation for how a multi-use building is defined.",
		"name":"Review Matches Against Multi-Use Buildings",
        	"hoot_key":"poi.polygon.review.multiuse.buildings"
    	    },
            {
        	"id":"poipolygon_source_tag_key",
        	"elem_type":"string",
        	"description":"The source tag key to be used in conjunction with poi.polygon.disable.same.source.conflation.",
        	"name":"Source Tag Key",
        	"defaultvalue":"source",
        	"hoot_key":"poi.polygon.source.tag.key",
        	"onchange":"true"
    	    },
            {
        	"id":"poipolygon_tag_merger",
        	"elem_type":"string",
        	"description":"The tag merger used by POI/Polygon conflation. See 'tag.merger.default' for more information. If 'poi.polygon.auto.merge.many.poi.to.one.poly.matches' is set to true then 'PreserveTypesTagMerger' is always used.",
        	"name":"Review If Types Match",
        	"defaultvalue":"PreserveTypesTagMerger",
		"required": "true",
        	"hoot_key":"poi.polygon.tag.merger",
        	"onchange":"true"
    	    },
    	    {
        	"id":"poipolygon_type_score_threshold",
        	"elem_type":"double",
        	"description":"The minimum similarity the type scores a POI and polygon can have and be considered a type match, with 0.0 being the least similar and 1.0 being the most similar.",
        	"name":"Type Score Threshold",
        	"defaultvalue":"0.7",
        	"minvalue":"0.01",
        	"maxvalue":"1.0",
        	"hoot_key":"poi.polygon.type.score.threshold"
    	    }
        ]
    },
    {
        "id":"hoot_power_line_options",
        "elem_type":"group",
        "description":"Hootenanny Power Line options",
        "name":"Power Line Options",
        "members":[
            {
                "id":"hoot_enable_power_line_options",
                "elem_type":"checkbox",
                "override":{
                    "elem_type":"checkbox"
                },
                "description":"Enable power line options",
                "name":"Enabled",
                "defaultvalue":"true",
                "onchange":"true"
            },
            {
                "id":"power_line_match_creator",
                "elem_type":"string",
                "description":"List of MatchCreators to use during conflation. This can modify what features will be conflated (e.g. buildings, roads, etc.).",
                "name":"Match Creator",
                "required":"true",
                "defaultvalue":"ScriptMatchCreator,PowerLine.js",
                "override":{
                    "defaultvalue":"ScriptMatchCreator,PowerLine.js"
                },
                "hoot_key":"match.creators"
            },
            {
                "id":"power_line_merger_creator",
                "elem_type":"string",
                "description":"List of MergerCreators to use during conflation. This can modify what features will be conflated (e.g. buildings, roads, etc.).",
                "name":"Merger Creator",
                "required":"true",
                "defaultvalue":"ScriptMergerCreator",
                "override":{
                    "defaultvalue":"ScriptMergerCreator"
                },
                "hoot_key":"merger.creators"
            },
            {
                "id":"power_line_auto_calc_search_radius",
                "elem_type":"bool",
                "description":"Automatically calculates the search radius to be used during conflation of power lines using rubber sheet tie point distances.  When this setting is enabled, rubbersheeting is not allowed as a pre-conflation operation on the input data to be conflated.",
                "name":"Power Line Auto Calculate Search Radius",
                "defaultvalue":"true",
                "disabled":"false",
                "hoot_key":"power.line.auto.calc.search.radius",
                "onchange":"true"
            },
            {
                "id":"power_line_distance_weight_coefficient",
                "minvalue":"0.0",
                "elem_type":"double",
                "description":"A weighting coefficient value from 0.0 to 1.0 for the applying distance weighting to power line matches.  This will favor feature that are closer together.  The higher the coefficient value, the higher the weighting applied.  A value of 0.0 will disable distance weighting.",
                "maxvalue":"1.0",
                "name":"Power Line Matcher Distance Weight Coefficient",
                "defaultvalue":"0.01",
                "hoot_key":"power.line.matcher.distance.weight.coefficient"
            },
            {
                "id":"power_line_matcher_max_angle",
                "minvalue":"0.0",
                "elem_type":"double",
                "description":"Sets that maximum angle that is still considered a power line match. Units in degrees.",
                "maxvalue":"360.0",
                "name":"Power Line Matcher Max Angle",
                "defaultvalue":"155.0",
                "hoot_key":"power.line.matcher.max.angle"
            },
            {
                "id":"power_line_subline_matcher",
                "elem_type":"string",
                "description":"The subline matcher to use when determining matching sublines for power lines.",
                "name":"Power Line Subline Matcher",
                "defaultvalue":"FrechetSublineMatcher",
                "hoot_key":"power.line.subline.matcher",
                "required":"true"
            }
        ]
    },
    {
        "id":"hoot_railway_options",
        "elem_type":"group",
        "description":"Hootenanny Railway options",
        "name":"Railway Options",
        "members":[
        {
            "id":"hoot_enable_railway_options",
            "elem_type":"checkbox",
            "override":{
                "elem_type":"checkbox"
            },
            "description":"Enable railway options",
            "name":"Enabled",
            "defaultvalue":"true",
            "onchange":"true"
        },
        {
            "id":"railway_match_creator",
            "elem_type":"string",
            "description":"List of MatchCreators to use during conflation. This can modify what features will be conflated (e.g. buildings, roads, etc.).",
            "name":"Match Creator",
            "required":"true",
            "defaultvalue":"ScriptMatchCreator,Railway.js",
            "override":{
                "defaultvalue":"ScriptMatchCreator,Railway.js"
            },
            "hoot_key":"match.creators"
        },
        {
            "id":"railway_merger_creator",
            "elem_type":"string",
            "description":"List of MergerCreators to use during conflation. This can modify what features will be conflated (e.g. buildings, roads, etc.).",
            "name":"Merger Creator",
            "required":"true",
            "defaultvalue":"ScriptMergerCreator",
            "override":{
                "defaultvalue":"ScriptMergerCreator"
            },
            "hoot_key":"merger.creators"
        },
        {
            "id":"railway_way_subline_matcher",
            "elem_type":"string",
            "description":"The way subline matcher to use when determining matching sublines.",
            "name":"Railway Subline Matcher",
            "defaultvalue":"MaximalSublineMatcher",
            "hoot_key":"railway.subline.matcher",
            "required":"true"
        },
        {
            "id":"railway_matcher_max_angle",
            "minvalue":"0.0",
            "maxvalue":"360.0",
            "defaultvalue":"90.0",
            "elem_type":"double",
            "description":"Sets that maximum angle that is still considered a railway match. Units in degrees.",
            "name":"Railway Matcher Max Angle",
            "hoot_key":"railway.matcher.max.angle"
        }
      ]
    },
    {
        "id":"hoot_river_options",
        "elem_type":"group",
        "description":"Hootenanny River options",
        "name":"River Options",
        "members":[
            {
                "id":"hoot_enable_river_options",
                "elem_type":"checkbox",
                "override":{
                    "elem_type":"checkbox"
                },
                "description":"Enable river options",
                "name":"Enabled",
                "defaultvalue":"true",
                "onchange":"true"
            },
            {
                "id":"river_match_creator",
                "elem_type":"string",
                "description":"List of MatchCreators to use during conflation. This can modify what features will be conflated (e.g. buildings, roads, etc.).",
                "name":"Match Creator",
                "required":"true",
                "defaultvalue":"ScriptMatchCreator,River.js",
                "override":{
                    "defaultvalue":"ScriptMatchCreator,River.js"
                },
                "hoot_key":"match.creators"
            },
            {
                "id":"river_merger_creator",
                "elem_type":"string",
                "description":"List of MergerCreators to use during conflation. This can modify what features will be conflated (e.g. buildings, roads, etc.).",
                "name":"Merger Creator",
                "required":"true",
                "defaultvalue":"ScriptMergerCreator",
                "override":{
                    "defaultvalue":"ScriptMergerCreator"
                },
                "hoot_key":"merger.creators"
            },
            {
                "id":"river_way_angle_sample_distance",
                "minvalue":"0.01",
                "elem_type":"double",
                "description":"Distance, in meters, used for sampling during angle histogram extraction with the SampledAngleHistogramExtractor",
                "maxvalue":"",
                "name":"River Angle Sample Distance",
                "defaultvalue":"20.0",
                "hoot_key":"river.angle.sample.distance"
            },
            {
                "id":"river_way_auto_calc_search_radius",
                "elem_type":"bool",
                "description":"Automatically calculates the search radius to be used during conflation of rivers using rubber sheet tie point distances.  When this setting is enabled, rubbersheeting is not allowed as a pre-conflation operation on the input data to be conflated.",
                "name":"River Auto Calculate Search Radius",
                "defaultvalue":"true",
                "disabled":"false",
                "hoot_key":"river.auto.calc.search.radius",
                "onchange":"true"
            },
            {
                "id":"river_rubber_sheet_ref",
                "elem_type":"bool",
                "description":"When auto-calculating a search radius, if this configuration setting is set to true then the first layer is treated as the reference layer and will not be moved. If set to false, the two layers will be moved towards each other. The weighting is determined based on the circular error.  This is separate from the global Rubber Sheeting Ref option.",
                "name":"River Auto-Search Radius Calculation Rubber Sheet Ref",
                "defaultvalue":"true",
                "hoot_key":"river.rubber.sheet.ref"
            },
            {
                "id":"river_rubber_sheet_minimum_ties",
                "minvalue":"0",
                "elem_type":"int",
                "description":"Sets the minimum number of rubber sheet tie points that will be used when auto-calculating a search radius.  This is separate from the global Rubber Sheeting Minimum Ties option.",
                "maxvalue":"",
                "name":"River Auto-Search Radius Minimum Ties Required",
                "defaultvalue":"5",
                "hoot_key":"river.rubber.sheet.minimum.ties"
            },
            {
                "id":"river_way_matcher_heading_delta",
                "minvalue":"0.0",
                "elem_type":"double",
                "description":"The distance around a point on a way to look when calculating the heading. A larger value will smooth out the heading values on a line. A smaller value will make the heading values correspond directly to the heading on the way at that point. This is primarily used in subline matching. Values are in meters.",
                "maxvalue":"360.0",
                "name":"River Matcher Heading Delta",
                "defaultvalue":"150.0",
                "hoot_key":"river.matcher.heading.delta"
            },
            {
                "id":"river_matcher_max_angle",
                "minvalue":"0.0",
                "elem_type":"double",
                "description":"Sets that maximum angle that is still considered a river match. Units in degrees.",
                "maxvalue":"360.0",
                "name":"River Matcher Max Angle",
                "defaultvalue":"90.0",
                "hoot_key":"river.matcher.max.angle"
            },
            {
                "id":"search_radius_river",
                "minvalue":"-1",
                "elem_type":"double",
                "description":"The search radius to use when conflating rivers. If two features are within the search radius then they will be considered for conflation. If the value is -1 then the circular error will be used to calculate an appropriate search radius.",
                "maxvalue":"",
                "name":"River Search Radius",
                "defaultvalue":"-1",
                "disabled":"true",
                "override":{
                    "defaultvalue":"-1"
                },
                "hoot_key":"search.radius.river"
            },
            {
                "id":"river_way_subline_matcher",
                "elem_type":"string",
                "description":"The way subline matcher to use when determining matching sublines.",
                "name":"River Subline Matcher",
                "defaultvalue":"MaximalSublineMatcher",
                "hoot_key":"river.subline.matcher",
                "required":"true"
            }
        ]
    }
]
