#!/usr/bin/perl -w

use strict;
use Fcntl;
use Math::Trig; # For tile number calculations
use POSIX qw(strftime);
use File::Temp qw(tempfile);
use Data::Dumper;
use Tie::LevelDB;

sub covertDecimalDegreesToNanodegrees($);
sub generatePgDumpfileFromOsm($$);
sub readNodes($$$$);
sub readWays($$$$);
sub readRelations($$$$);
sub lon2x($);
sub lat2y($);
sub convertLatLonToTileNumber($$);
sub generateISO8601Time();
sub addChangeToChangeset($);
sub updateHeaderTables($$);
sub generateUsersTable($);
sub closeChangesetsTable($);
sub writeChangesetEntry($);

# A handful of globals to make life easier
my $changesetId = 1;
my %changesetChangeCount;
$changesetChangeCount{ $changesetId } = 0;

sub addChangeToChangeset($)
{
  my $sectionFilehandlesRef = shift(@_);

  $changesetChangeCount{ $changesetId } += 1;

  if ( $changesetChangeCount{ $changesetId } == 50000 )
  {
    writeChangesetEntry($sectionFilehandlesRef);
    $changesetId++;
    $changesetChangeCount{ $changesetId } = 0;
  }
}

sub writeChangesetEntry($)
{
  my $sectionFilehandlesRef = shift(@_);
  my $changesetsTable = $sectionFilehandlesRef->{'changesets' };
  my $currentTimestamp = generateISO8601Time();

  # Is this first time we've been called?
  if ( $changesetId == 1 )
  {
    print( $changesetsTable
      "COPY changesets (id, user_id, created_at, closed_at, num_changes) FROM stdin;\n"
    );
  }

  print( $changesetsTable 
    sprintf( "%d\t1\t%s\t%s\t%d\n", $changesetId, $currentTimestamp, $currentTimestamp,
      $changesetChangeCount{ $changesetId } )
  );
}

sub convertDecimalDegreesToNanodegrees($)
{
  my $decimalDegrees = shift(@_);
  #print("Input degrees: $decimalDegrees\n");

  my $nanoDegrees = sprintf("%10d", ($decimalDegrees * 10000000.0));
  #print( "In nanodegrees: $nanoDegrees\n" );

  return $nanoDegrees;
}

sub lon2x($)
{
  my $lon = shift(@_);

  # Note perl does not have a rounding function, so stackoverflow says
  #     stealing from printf is about as close as you can come
  return int(sprintf("%.0f", (($lon + 180.0) * 65535.0 / 360.0)))
}

sub lat2y($)
{
  my $lat = shift(@_);

  return int(sprintf("%.0f", (($lat + 90.0) * 65535.0 / 180.0)));
}

sub convertLatLonToTileNumber($$)
{
  my $lat = shift(@_);
  my $lon = shift(@_);

  my $y = lat2y($lat);
  my $x = lon2x($lon);

  my $tile = 0;

  for ( my $i = 15; $i >= 0; $i-- )
  {
    $tile = ($tile << 1) | (($x >> $i) & 1);
    $tile = ($tile << 1) | (($y >> $i) & 1);
  }

  #print( "Tile calc for x=$lon, y=$lat: $tile\n");

  #exit;

  return $tile;
}

sub generateISO8601Time()
{
  return strftime("%F %T", gmtime(time()));
}


sub generatePgDumpfileFromOsm($$)
{
  my $osmFilename = shift(@_);
  my $sqlFilename = shift(@_);
  my $idMappings  = new Tie::LevelDB::DB("idmaps.db");
  my $osmFilehandle;

  open( $osmFilehandle, "< $osmFilename") or die( "Could not open OSM file: $osmFilename\n\n" );

  # Open multiple temp output SQL files, one per table. 
  #
  # Having one file per table/section frees us up to do ONE pass over each kind of data, nodes/ways/relations,
  #   into the appropriate file:
  #
  #   At the end we'll do an OS filesystem concat of the various files to get the correct ordering of 
  #   tables in the final output. Saves huge time

  my @fileSections = (
    'sequence_updates',
    'users',
    'changesets',
    'current_nodes',
    'current_node_tags',
    'nodes',
    'node_tags',
    'current_ways',
    'current_way_nodes',
    'current_way_tags',
    'ways',
    'way_nodes',
    'way_tags',
    'current_relations',
    'current_relation_members',
    'current_relation_tags',
    'relations',
    'relation_members',
    'relation_tags'
  );

  my %sectionFilehandles;

  foreach my $currSection ( @fileSections )
  {
    $sectionFilehandles{ $currSection } = File::Temp->new(DIR=>'.');
  }

  my $startingNodeId  = 500;

  readNodes($osmFilehandle, \%sectionFilehandles, $startingNodeId, $idMappings );

  #print( "\nShould be first way line:\n\t" . <$osmFilehandle> );

  # Process ways
  my $startingWayId   = 500;
  readWays($osmFilehandle, \%sectionFilehandles, $startingWayId, $idMappings );

  # Process relations
  my $startingRelationId = 500;
  readRelations( $osmFilehandle, \%sectionFilehandles, $startingRelationId, $idMappings );

  close( $osmFilehandle );
  #close( $sqlFilehandle );

  # Close out tables
  closeChangesetsTable(\%sectionFilehandles);

  # Populate data for header tables
  updateHeaderTables(\%sectionFilehandles, $startingNodeId);

  if ( -f $sqlFilename )
  {
    unlink($sqlFilename);
  }

  foreach my $currSection ( @fileSections )
  {
    `cat $sectionFilehandles{ $currSection } >> $sqlFilename`;
  }
}

sub readNodes($$$$)
{
  my $osmFilehandle           = shift(@_);
  my $sectionFilehandlesRef   = shift(@_);
  my $startingNodeId          = shift(@_);
  my $idMappings              = shift(@_);

  print( "- Processing nodes: ");

  my $currentNodesHandle = $sectionFilehandlesRef->{'current_nodes'};

  print( $currentNodesHandle
    'COPY current_nodes (id, latitude, longitude, changeset_id, ' .
    "visible, \"timestamp\", tile, version) FROM stdin;\n" );

  my $currentNodeTagsHandle = $sectionFilehandlesRef->{'current_node_tags'};

  print( $currentNodeTagsHandle "COPY current_node_tags (node_id, k, v) FROM stdin;\n" );

  my $nodesHandle = $sectionFilehandlesRef->{'nodes'};
 
  print( $nodesHandle
    'COPY nodes (node_id, latitude, longitude, changeset_id, visible, ' .
    '"timestamp", tile, version, redaction_id) FROM stdin;' . "\n" );

  my $nodeTagsHandle = $sectionFilehandlesRef->{'node_tags'};

  print ( $nodeTagsHandle "COPY node_tags (node_id, version, k, v) FROM stdin;\n" );

  # Timestamp that will be used for all nodes
  my $timestamp = generateISO8601Time();

  # Read until we get something of interest (node, way, relation, or close OSM tag
  my $previousLinePosition = tell($osmFilehandle );
  my $currLine = <$osmFilehandle>;
  my $numNodes = 0;
  my $dbNodeId = $startingNodeId;

  my $nodeId;   # Have to track this outside loop as tags will refer back to 
                # last node we encountered

  my $insideNode = 0;

  my $nodesInBatch = 0;
  my $maxNodesPerBatch = 10000000;

  my $nodeBatch = new Tie::LevelDB::WriteBatch();

  while ( ! eof($osmFilehandle) )
  {
    chomp( $currLine );
    #print( "Read line: $currLine\n" );

    # If it's something past nodes, bail out
    if ( $currLine =~ /<(?:(?:way|relation) id=\"-?\d+\"|\/osm>)/ )
    {
      last;
    }

    # If it's a node, deal with it
    if ( $currLine =~ /<node\s+id=\"-?\d+\"/ )
    {

      # Make sure we're not already inside a node
      if ( $insideNode == 1 )
      {
        print( "Hit node start when we were already in one $currLine\n\n");
        exit;
      }

      # Mark that we're inside a node
      $insideNode = 1;

      #print( "Processing node in line $currLine" );
      $numNodes++;

      # Parse node line
      if ( $currLine !~ 
        /<node\s+id=\"(.+?)\"\s+lat=\"(.+?)\"\s+lon=\"(.+?)\"\s+/ )
      {
        print( "\nERROR: invalid node line $currLine, bailing\n\n");
        exit;
      }

      $nodeId  = $1;
      my $nodeLat = $2;
      my $nodeLon = $3;
      my $tileNumber = convertLatLonToTileNumber($nodeLat, $nodeLon);

      # Establish node ID mapping
      $nodeBatch->Put( "node:$nodeId", $dbNodeId );
      $nodesInBatch++;
      if ( $nodesInBatch == $maxNodesPerBatch )
      {
        $idMappings->Write($nodeBatch);
        $nodesInBatch = 0;
      }

      #print("Established node mapping, $nodeId -> $dbNodeId\n" );

      #print( "Tile number: " . convertLatLonToTileNumber($nodeLat, $nodeLon) . "\n" );

      # Print current version of data
      print( $currentNodesHandle
        sprintf("%d\t%10d\t%10d\t%d\tt\t%s\t%u\t1\n",
          $dbNodeId,
          convertDecimalDegreesToNanodegrees($nodeLat),
          convertDecimalDegreesToNanodegrees($nodeLon),
          $changesetId,
          $timestamp,
          $tileNumber));

      # Print historical version of data
      print( $nodesHandle
        sprintf( "%d\t%10d\t%10d\t%d\tt\t%s\t%u\t1\t\\N\n",
          $dbNodeId,
          convertDecimalDegreesToNanodegrees($nodeLat),
          convertDecimalDegreesToNanodegrees($nodeLon),
          $changesetId,
          $timestamp,
          $tileNumber));

      #print( "Tile number: $tileNumber\n" );

      $dbNodeId++;

      # Add the change to the changeset -- allows for maintaining changeset ID
      addChangeToChangeset($sectionFilehandlesRef);

      # Identify if this is a node without tags, should we say we're leaving this node?
      if ( $currLine =~ /<node.+?\/>\s*$/ )
      {
        $insideNode = 0;
        $nodeId = -999999;
      }
    }
    elsif ( $currLine =~ /<tag\s+k=\"(.*?)\"\s+v=\"(.*?)\"\s*\/>/ )
    {
      # Are we inside a node?
      if ( $insideNode == 0 )
      {
        print( "Encountered an unexpected node tag\n\n");
        exit;
      }

      my $tagKey = $1;
      my $tagValue = $2;

      # Print to the two tag tables
      print( $currentNodeTagsHandle 
        sprintf("%d\t%s\t%s\n", $dbNodeId, $tagKey, $tagValue) );
      print( $nodeTagsHandle
        sprintf("%d\t1\t%s\t%s\n", $dbNodeId, $tagKey, $tagValue) );
    }
    elsif ( $currLine =~ /<\/node>/ )
    {
      # We've left a node
      $insideNode = 0;
      $nodeId = -999999;
    }
    else
    {
      # Ignore anything before first node, otherwise error
      if ( $numNodes > 0 )
      {
        print( "Invalid line: $currLine\n\n");
        exit;
      }
    }

    $previousLinePosition = tell($osmFilehandle );
    $currLine = <$osmFilehandle>;
  }

  # Do last node ID mapping batch flush if necessary
  if ( $nodesInBatch > 0 )
  {
    $idMappings->Write($nodeBatch);
    $nodesInBatch = 0;
  }

  # Output marker for end of tables
  my $endOfTableTag = "\\.\n\n\n";
  print( $currentNodesHandle    $endOfTableTag );
  print( $currentNodeTagsHandle $endOfTableTag );
  print( $nodesHandle           $endOfTableTag );
  print( $nodeTagsHandle        $endOfTableTag );

  print ("complete ($numNodes)\n");

  #print( "Stopped looking for nodes at $currLine" ); 

  # Reset filehandle back one line so the next processing section starts at correct point
  $osmFilehandle = seek( $osmFilehandle, $previousLinePosition, Fcntl::SEEK_SET );
}

sub readWays($$$$)
{
  my $osmFilehandle           = shift(@_);
  my $sectionFilehandlesRef   = shift(@_);
  my $startingWayId           = shift(@_);
  my $idMappings              = shift(@_);

  print( "- Processing ways: ");

  my $currentWaysHandle = $sectionFilehandlesRef->{'current_ways'};
  print( $currentWaysHandle
    "COPY current_ways (id, changeset_id, \"timestamp\", visible, version) FROM stdin;\n" );

  my $currentWayTagsHandle = $sectionFilehandlesRef->{'current_way_tags'};
  print( $currentWayTagsHandle "COPY current_way_tags (way_id, k, v) FROM stdin;\n" );

  my $currentWayNodesHandle = $sectionFilehandlesRef->{'current_way_nodes'};
  print( $currentWayNodesHandle "COPY current_way_nodes (way_id, node_id, sequence_id) FROM stdin;\n" );

  my $waysHandle = $sectionFilehandlesRef->{'ways'};
  print( $waysHandle
    "COPY ways (way_id, changeset_id, \"timestamp\", version, visible, redaction_id) FROM stdin;\n" );

  my $wayTagsHandle = $sectionFilehandlesRef->{'way_tags'};
  print ( $wayTagsHandle "COPY way_tags (way_id, k, v, version) FROM stdin;\n" );

  my $wayNodesHandle = $sectionFilehandlesRef->{'way_nodes'};
  print( $wayNodesHandle "COPY way_nodes (way_id, node_id, version, sequence_id) FROM stdin;\n" );

  # Timestamp that will be used for all nodes
  my $timestamp = generateISO8601Time();

  # Read until we get something of interest (way, relation, or close OSM tag
  my $previousLinePosition = tell($osmFilehandle );
  my $currLine = <$osmFilehandle>;
  my $numWays = 0;
  my $numWayNodes = 0;
  my $dbWayId = $startingWayId;

  my $wayId;   # Have to track this outside loop as tags will refer back to
                # last way we encountered
  my $insideWay = 0;
  my $nodeSequence = -99999;
  my $waysInBatch = 0;
  my $maxWaysPerBatch = 10000000;

  my $waysBatch = new Tie::LevelDB::WriteBatch();

  while ( ! eof($osmFilehandle) )
  {
    chomp( $currLine );
    #print( "Read line: $currLine\n" );

    # If it's something past ways, bail out
    if ( $currLine =~ /<(?:(relation id=\"-?\d+\"|\/osm>))/ )
    {
      last;
    }

    # If it's a way, deal with it
    if ( $currLine =~ /<way\s+id=\"-?\d+\"/ )
    {

      # Make sure we're not already inside a way
      if ( $insideWay == 1 )
      {
        print( "Hit way start when we were already in one: $currLine\n\n");
        exit;
      }

      # Mark that we're inside a way, start its node sequence over
      $insideWay = 1;
      $nodeSequence = 1;

      #print( "Processing way in line $currLine" );
      $numWays++;

      # Parse way line
      if ( $currLine !~
        /<way\s+id=\"(.+?)\"/ )
      {
        print( "\nERROR: invalid way line $currLine, bailing\n\n");
        exit;
      }

      $wayId  = $1;

      # Establish way ID mapping
      $waysBatch->Put( "way:$wayId", $dbWayId );
      $waysInBatch++;
      if ( $waysInBatch == $maxWaysPerBatch )
      {
        $idMappings->Write($waysBatch);
        $waysInBatch = 0;
      }

      #print("Established way mapping, $wayId -> $dbWayId\n" );

      # Print current version of data
      print( $currentWaysHandle
        sprintf("%d\t%d\t%s\tt\t1\n",
          $dbWayId,
          $changesetId,
          $timestamp ) );

      # Print historical version of data
      print( $waysHandle
        sprintf( "%d\t%d\t%s\t1\tt\t\\N\n",
          $dbWayId,
          $changesetId,
          $timestamp ) );

      $dbWayId++;

      # Add the change to the changeset -- allows for maintaining changeset ID
      addChangeToChangeset($sectionFilehandlesRef);

      # Identify if this is a way without tags, should we say we're leaving this way?
      if ( $currLine =~ /<way.+?\/>\s*$/ )
      {
        $insideWay = 0;
        $wayId = -999999;
        $nodeSequence = -999999;
      }
    }

    elsif ( $currLine =~ /<tag\s+k=\"(.*?)\"\s+v=\"(.*?)\"\s*\/>/ )
    {
      # Are we inside a way?
      if ( $insideWay == 0 )
      {
        print( "Encountered an unexpected way tag\n\n");
        exit;
      }

      my $tagKey = $1;
      my $tagValue = $2;

      # Print to the two tag tables
      print( $currentWayTagsHandle
        sprintf("%d\t%s\t%s\n", $dbWayId, $tagKey, $tagValue) );
      print( $wayTagsHandle
        sprintf("%d\t%s\t%s\t1\n", $dbWayId, $tagKey, $tagValue) );
    }
    elsif ( $currLine =~ /<nd\s+ref=\"(.+)\"\s*\/>/ )
    {
      if ( $insideWay == 0 )
      {
        print( "Encountered unexpected node ref: $currLine\n\n" );
        exit;
      }

      my $nodeRefId = $1;

      # Is it a known node ref?
      my $dbNodeRefId = $idMappings->Get( "node:$nodeRefId" );
      if ( ! defined($dbNodeRefId) )
      {
        print( "Ignoring unresolved node ref $nodeRefId in way $wayId\n");
      }

      #print ( "Found valid node ref $nodeRefId, DB ID $dbNodeRefId for way $wayId\n" );
      #exit;

      print( $currentWayNodesHandle
        sprintf("%d\t%d\t%u\n", $dbWayId, $dbNodeRefId, $nodeSequence) );

      print( $wayNodesHandle
        sprintf("%d\t%d\t1\t%d\n", $dbWayId, $dbNodeRefId, $nodeSequence) );

      # Increment node sequence value
      $nodeSequence++;

      # Increment total count of waynodes
      $numWayNodes++;
    }
    elsif ( $currLine =~ /<\/way>/ )
    {
      # We've left a way
      $insideWay = 0;
      $wayId = -999999;
      $nodeSequence = -999999;
    }
    else
    {
      print( "Invalid line: $currLine\n\n");
      exit;
    }

    $previousLinePosition = tell($osmFilehandle );
    $currLine = <$osmFilehandle>;
  }

  if ( $waysInBatch > 0 ) 
  {
    $idMappings->Write( $waysBatch );
    $waysInBatch = 0;
  }

  # Output marker for end of tables
  my $endOfTableTag = "\\.\n\n\n";
  print( $currentWaysHandle     $endOfTableTag );
  print( $currentWayNodesHandle $endOfTableTag );
  print( $currentWayTagsHandle  $endOfTableTag );
  print( $waysHandle            $endOfTableTag );
  print( $wayNodesHandle        $endOfTableTag );
  print( $wayTagsHandle         $endOfTableTag );

  print ("complete ($numWays ways containing $numWayNodes waynodes)\n");

  #print( "Stopped looking for nodes at $currLine" );

  # Reset filehandle back one line so the next processing section starts at correct point
  $osmFilehandle = seek( $osmFilehandle, $previousLinePosition, Fcntl::SEEK_SET );
}

sub readRelations($$$$)
{
  my $osmFilehandle           = shift(@_);
  my $sectionFilehandlesRef   = shift(@_);
  my $startingRelationId      = shift(@_);
  my $idMappings              = shift(@_);

  print( "- Processing relations: ");

  my $currentRelationsHandle = $sectionFilehandlesRef->{'current_relations'};
  print( $currentRelationsHandle
    "COPY current_relations (id, changeset_id, \"timestamp\", visible, version) FROM stdin;\n" );

  my $currentRelationTagsHandle = $sectionFilehandlesRef->{'current_relation_tags'};
  print( $currentRelationTagsHandle "COPY current_relation_tags (relation_id, k, v) FROM stdin;\n" );

  my $currentRelationMembersHandle = $sectionFilehandlesRef->{'current_relation_members'};
  print( $currentRelationMembersHandle 
    "COPY current_relation_members (relation_id, member_type, member_id, member_role, sequence_id) FROM stdin;\n" );

  my $relationsHandle = $sectionFilehandlesRef->{'relations'};
  print( $relationsHandle
    "COPY relations (relation_id, changeset_id, \"timestamp\", version, visible, redaction_id) FROM stdin;\n" );

  my $relationTagsHandle = $sectionFilehandlesRef->{'relation_tags'};
  print ( $relationTagsHandle "COPY relation_tags (relation_id, k, v, version) FROM stdin;\n" );

  my $relationMembersHandle = $sectionFilehandlesRef->{'relation_members'};
  print( $relationMembersHandle "COPY relation_members (relation_id, member_type, member_id, member_role, version, sequence_id) FROM stdin;\n" );

  # Timestamp that will be used for all nodes
  my $timestamp = generateISO8601Time();

  # Read until we get something of interest (way, relation, or close OSM tag
  my $previousLinePosition = tell($osmFilehandle );
  my $currLine = <$osmFilehandle>;
  my $numRelations = 0;
  my $dbRelationId = $startingRelationId;

  my $relationId;   # Have to track this outside loop as tags will refer back to
                # last relation we encountered
  my $insideRelation = 0;
  my $memberSequence = -99999;
  my $numResolvedRelationMembers = 0;
  my $numUnresolvedRelationMembers = 0;
  my %unresolvedRelationMembers;

  while ( ! eof($osmFilehandle) )
  {
    chomp( $currLine );
    #print( "Read line: $currLine\n" );

    # If it's something past relation, bail out
    if ( $currLine =~ /<\/osm>/ )
    {
      last;
    }

    # If it's a relation, deal with it
    if ( $currLine =~ /<relation\s+id=\"-?\d+\"/ )
    {

      # Make sure we're not already inside a relation 
      if ( $insideRelation == 1 )
      {
        print( "Hit relation start when we were already in one: $currLine\n\n");
        exit;
      }

      # Mark that we're inside a relation, start its member sequence over
      $insideRelation = 1;
      $memberSequence = 1;

      #print( "Processing way in line $currLine" );
      $numRelations++;

      # Parse relation line
      if ( $currLine !~
        /<relation\s+id=\"(.+?)\"/ )
      {
        print( "\nERROR: invalid relation line $currLine, bailing\n\n");
        exit;
      }

      $relationId  = $1;

      # Establish relation ID mapping
      $idMappings->Put("relation:$relationId", $dbRelationId);

      #print("Established relation mapping, $relationId -> $dbRelationId\n");

      # Print current version of data
      print( $currentRelationsHandle
        sprintf("%d\t%d\t%s\tt\t1\n",
          $dbRelationId,
          $changesetId,
          $timestamp ) );

      # Print historical version of data
      print( $relationsHandle
        sprintf( "%d\t%d\t%s\t1\tt\t\\N\n",
          $dbRelationId,
          $changesetId,
          $timestamp ) );

      # Check for previously-unresolved relation members that pointed to this relation that we can now resolve
      if ( exists($unresolvedRelationMembers{$relationId}) )
      {
        #print("Deferred writes waiting on just-written relation $relationId, DB id = $dbRelationId!\n");
        #print( Dumper($unresolvedRelationMembers{$relationId}) );

        foreach my $deferredWrite ( @{ $unresolvedRelationMembers{$relationId} } )
        {
          my $dbSourceRelationId = $idMappings->Get("relation:$deferredWrite->{'relation_id'}");

          print( $currentRelationMembersHandle
            sprintf("%d\t%s\t%d\t%s\t%u\n", $dbSourceRelationId, ucfirst($deferredWrite->{'member_type'}), 
              $dbRelationId,
              lc($deferredWrite->{'member_role'}), $deferredWrite->{'member_sequence'}) );

          print( $relationMembersHandle
            sprintf("%d\t%s\t%d\t%s\t1\t%u\n", $dbSourceRelationId, 
              ucfirst($deferredWrite->{'member_type'}), $dbRelationId,
              lc($deferredWrite->{'member_role'}), $deferredWrite->{'member_sequence'}) );

           # As it actually got written out, update number of relation members
           $numUnresolvedRelationMembers--;
           $numResolvedRelationMembers++;
        }

        # Remove entry from unresolved list
        delete( $unresolvedRelationMembers{$relationId} );
      }

      $dbRelationId++;

      # Add the change to the changeset -- allows for maintaining changeset ID
      addChangeToChangeset($sectionFilehandlesRef);

      # Identify if this is a relation without members, should we say we're leaving this way?
      if ( $currLine =~ /<relation.+?\/>\s*$/ )
      {
        $insideRelation = 0;
        $relationId = -999999;
        $memberSequence = -999999;
      }
    }

    elsif ( $currLine =~ /<tag\s+k=\"(.*?)\"\s+v=\"(.*?)\"\s*\/>/ )
    {
      # Are we inside a relation?
      if ( $insideRelation == 0 )
      {
        print( "Encountered an unexpected relation tag\n\n");
        exit;
      }

      my $tagKey = $1;
      my $tagValue = $2;

      # Print to the two tag tables
      print( $currentRelationTagsHandle
        sprintf("%d\t%s\t%s\n", $dbRelationId, $tagKey, $tagValue) );
      print( $relationTagsHandle
        sprintf("%d\t%s\t%s\t1\n", $dbRelationId, $tagKey, $tagValue) );
    }

    elsif ( $currLine =~ /<member\s+type=\"(.+?)\"\s+ref=\"(.+?)\"\s+role=\"(.*?)\"\s*\/>/ )
    {
      if ( $insideRelation == 0 )
      {
        print( "Encountered unexpected relation member: $currLine\n\n" );
        exit;
      }

      my $memberType = $1;
      my $memberRefId = $2;
      my $memberRole = $3;

      # Confirm sane member type
      if ($memberType !~ /^(?:node|way|relation)$/ )
      {
        print( "Unknown member type in $currLine\n\n" );
        exit;
      }

      # Is it a known ref?
      my $dbMemberRefId = $idMappings->Get( "$memberType:$memberRefId" );

      if ( ! defined($dbMemberRefId) )
      {
        $numUnresolvedRelationMembers++;
        if ( $memberType ne 'relation' )
        {
          #print( "Ignoring unresolved member ref to $memberType $memberRefId in relation $relationId\n");
        }
        else
        {
          #print("Adding member ref to relation $memberRefId to unresolved list for possible later addition\n");
          # Add unresolved member refs to relations to deferred list, check deferrred list as new relations written
          if ( ! exists($unresolvedRelationMembers{ $memberRefId }) )
          {
            $unresolvedRelationMembers{ $memberRefId } = [ ];
          }

          push( @{ $unresolvedRelationMembers{$memberRefId} }, { 'relation_id' => $relationId, 'member_type' => $memberType,
            'member_role' => $memberRole, 'member_sequence' => $memberSequence } );
        }
      }
      else
      {
        #print( "Found valid member ref to $memberType $memberRefId in relation $relationId\n" );

        print( $currentRelationMembersHandle
          sprintf("%d\t%s\t%d\t%s\t%u\n", $dbRelationId, ucfirst($memberType), 
          $dbMemberRefId, lc($memberRole), $memberSequence) );

        print( $relationMembersHandle
          sprintf("%d\t%s\t%d\t%s\t1\t%u\n", $dbRelationId, ucfirst($memberType), 
          $dbMemberRefId, lc($memberRole), $memberSequence) );

        # As it actually got written out, update number of relation members
        $numResolvedRelationMembers++;

        # Increment member sequence value
        $memberSequence++;
      }
    }
    elsif ( $currLine =~ /<\/relation>/ )
    {
      # We've left relation
      $insideRelation = 0;
      $relationId = -999999;
      $memberSequence = -999999;
    }
    else
    {
      print( "Invalid line: $currLine\n\n");
      exit;
    }

    $previousLinePosition = tell($osmFilehandle );
    $currLine = <$osmFilehandle>;
  }

  # Output marker for end of tables
  my $endOfTableTag = "\\.\n\n\n";
  print( $currentRelationsHandle        $endOfTableTag );
  print( $currentRelationTagsHandle     $endOfTableTag );
  print( $currentRelationMembersHandle  $endOfTableTag );
  print( $relationsHandle               $endOfTableTag );
  print( $relationTagsHandle            $endOfTableTag );
  print( $relationMembersHandle         $endOfTableTag );

  print ("complete ($numRelations relations containing $numResolvedRelationMembers valid members and $numUnresolvedRelationMembers unresolved members)\n");

  #print( "Stopped looking for nodes at $currLine" );

  # Reset filehandle back one line so the next processing section starts at correct point
  $osmFilehandle = seek( $osmFilehandle, $previousLinePosition, Fcntl::SEEK_SET );
}



sub updateHeaderTables($$)
{
  my $sectionFilehandlesRef = shift(@_);
  my $startingNodeId = shift(@_);

  generateUsersTable($sectionFilehandlesRef);
}

sub generateUsersTable($)
{
  my $sectionFilehandlesRef = shift(@_);
  my $usersTable = $sectionFilehandlesRef->{ 'users' };
  my $currentTimestamp = generateISO8601Time();

  print( $usersTable
    "COPY users (email, id, pass_crypt, creation_time ) FROM stdin;\n" .
    "mapedit_ingest\@digitalglobe.com\t1\tabcdefg\t$currentTimestamp\n" .
    "\\.\n\n\n"
  );
}

sub closeChangesetsTable($)
{
  my $sectionFilehandlesRef = shift(@_);
  my $changesetsTable = $sectionFilehandlesRef->{'changesets' };

  # If we haven't yet written the current entry, time to do it now
  if ( $changesetChangeCount{ $changesetId } != 0 )
  {
    writeChangesetEntry($sectionFilehandlesRef);
  }

  print( $changesetsTable "\\.\n\n\n" );
}


if ( scalar(@ARGV) != 2 ) 
{
  print( "Usage: convertOsmXmlToPgsqlDump <.osm input file> <.sql output file>\n\n" );
  exit;
}

my $osmFilename = $ARGV[0];
my $sqlFilename = $ARGV[1];

print( "OSM file: $osmFilename\n" );
print( "SQL file: $sqlFilename\n" );

print("\n");
generatePgDumpfileFromOsm( $osmFilename, $sqlFilename );
