#!/usr/bin/perl -w

# Compare the contents of an OSM XML file to a database dump (created with pg_dump) 
# of an OSM API database after that OSM XML file has been uploaded to it
#
# NOTE: this script requires the Perl module "XML::Simple" to be installed
#
# On Ubuntu 14.04, this can be installed using the following:
#
#     sudo apt-get install libxml-simple-perl

use strict;
require XML::Simple;

use XML::Simple qw(:strict);
use Data::Dumper;

sub createOsmDom($$);
sub validateOsmXmlNodes($$);
sub validateCurrentNodes($$);
sub validateNodes($$);
sub validateOsmXmlWays($$);
sub validateCurrentWays($$);
sub validateWays($$);

sub convertNanodegreesStringToDegrees($);

# Globals for data
my %nodesOsm;
my %nodesPgsql;
my %nodeIdMappingsXmlToDb;
my %wayIdMappingsXmlToDb;

sub convertNanodegreesStringToDegrees($)
{
  #my $nanodegreesString = shift(@_);
  #print( "\tInput nanodegree string: $nanodegreesString\n");

  #my $nanodegrees = ($nanodegreesString * 1.0);

  #my $degrees = ( $nanodegrees / 10000000.0 );
  #print( "\tComputed degrees: $degrees\n\n");
  #return $degrees;

  return ( shift(@_) / 10000000.0 );
}

sub createOsmDom($$)
{
  my $xs = shift(@_);
  my $xmlString = shift(@_);

  my $domRef = $xs->XMLin($xmlString, 
    KeyAttr => { node => 'id', way => 'id' }, 
    ForceArray => [ 'node', 'tag', 'way', 'nd' ] );

  return $domRef;
}

sub validateOsmXmlNodes($$)
{
  my $osmXmlNodesRef = shift(@_);
  my $dumpLinesRef = shift(@_);

  print("Validating data: nodes\n");

  validateCurrentNodes($osmXmlNodesRef, $dumpLinesRef);
  validateNodes($osmXmlNodesRef, $dumpLinesRef);
}

sub validateCurrentNodes($$)
{
  my $osmXmlNodesRef = shift(@_);
  my $dumpLinesRef = shift(@_);

  my @dumpLines = @{$dumpLinesRef};

  my %currentNodesData;

  my $currLine;

  # Checking table: current_nodes
  print( "\tcurrent_nodes, current_node_tags:\n");
  my $foundStart = 0;
  foreach $currLine (@dumpLines)
  {
    chomp($currLine);

    # Find out where current_nodes starts
    if ( $foundStart == 0 ) 
    {
      if ($currLine =~ /^COPY current_nodes .+ FROM stdin;/ )
      {
        $foundStart = 1;
      }

      # Either way, can't do any more processing
      next;
    }

    # Are we at end of data?
    if ( $currLine =~ /^\\./ )
    {
      last;
    }

    #print( "Current_nodes entry: $currLine\n" );

    # Have a valid node
    my %currentNodesEntry;

    # Break into tokens based on tab delimiter
    # Schema: id, latitude, longitude, changeset_id, visible, "timestamp", tile, version
    my @tokens = split( /\s+/, $currLine);

    #print( "Found node, ID = $tokens[0]\n");
  
    $currentNodesEntry{'lat'} = convertNanodegreesStringToDegrees($tokens[1]);
    #print( "\tSource string: $tokens[1]\n");
    #print( "\tConverted latitude: $currentNodesEntry{'lat'}\n");

    $currentNodesEntry{'lon'} = convertNanodegreesStringToDegrees($tokens[2]);
    #print( "\tLongitude: $currentNodesEntry{'lon'}\n");

    $currentNodesEntry{'tile_num'} = $tokens[7];
    $currentNodesEntry{'version'} = $tokens[8];

    #print( "\tCoords (lat/lon): $currentNodesEntry{'lat'}, $currentNodesEntry{'lon'}\n");
    #print( "\tTile: $currentNodesEntry{'tile_num'}\n");
    #print( "\tVersion: $currentNodesEntry{'version'}\n");

    # Store the entry in hash of current_nodes
    $currentNodesData{$tokens[0]} = \%currentNodesEntry;
  }

  #print( 'Found ' . scalar(keys(%currentNodesData)) . " entries in current_nodes\n" );

  # Read current_node_tags

  $foundStart = 0;
  foreach $currLine (@dumpLines)
  {
    chomp($currLine);

    # Find out where table data starts
    if ( $foundStart == 0 )
    {
      if ($currLine =~ /^COPY current_node_tags .+ FROM stdin;/ )
      {
        $foundStart = 1;
      }

      # Either way, can't do any more processing
      next;
    }

    # Are we at end of data?
    if ( $currLine =~ /^\\./ )
    {
      last;
    }

    #print( "Current_node_tags entry: $currLine\n" );

    # Have a valid node
    my %currentNodeTagsEntry;

    # Break into tokens based on tab delimiter
    # Schema: node_id, key, value
    my @tokens = split( /\t+/, $currLine);

    #print( "Found node tag\n");

    $currentNodeTagsEntry{$tokens[1]} = $tokens[2];
    #print( "\tID: $tokens[0]\n\tKey: $tokens[1]\n\tValue: $tokens[2]\n");

    # Store the entry in hash of current_nodes
    if ( exists($currentNodesData{ $tokens[0] }->{'tags'} ) )
    {
      $currentNodesData{ $tokens[0] }->{'tags'}->{$tokens[1]} = $tokens[2];

      #my $key;
      #foreach $key ( keys( $currentNodesData{ $tokens[0] }->{'tags'}) )
      #{
      # print( "\tFound tags key: $key\n" );
      #}
    }
    else
    {
      $currentNodesData{ $tokens[0] }->{'tags'} = { $tokens[1] => $tokens[2] };
    }
  }

  # First sanity check: make sure # of OSM current_nodes exactly matches # of OSM API DB current_nodes
  #print( "Number of OSM nodes: " . scalar(keys(%$osmXmlNodesRef)) . "\n" );
  if ( scalar(keys(%$osmXmlNodesRef)) != scalar(keys(%currentNodesData)) )
  {
    print('ERROR: OSM XML nodes: ' . scalar(keys(%$osmXmlNodesRef)) .
      ' != OSM API DB nodes: ' . scalar(keys(%currentNodesData)) . "\n\n" );

    exit;
  }
  
  print( "\t\tMatching number of nodes: PASS (" . 
    scalar(keys(%currentNodesData)) . ")\n");

  # Now let's create mapping for Postgres Node ID -> OSM node ID.  the OSM XML node IDs were added in 
  #   ascending node ID order, so if we iterate over OSM API node IDs in ascending, we have a guaranteed mapping

  my @sortedDbNodeIds = sort( {$a <=> $b} keys(%currentNodesData));
  my $currXmlNodeId;
  my $i = 0;
  foreach $currXmlNodeId ( sort( {$a <=> $b} keys(%$osmXmlNodesRef)) )
  {
    $nodeIdMappingsXmlToDb{$currXmlNodeId} = $sortedDbNodeIds[$i];

    #print("XML node ID $currXmlNodeId maps to DB node ID $sortedDbNodeIds[$i]\n");

    $i++;
  }

  # Now that we have mapping, go back and compare each XML node to corresponding entry in current_nodes
  foreach $currXmlNodeId ( sort( {$a <=> $b} keys(%$osmXmlNodesRef)) )
  {
    my %currXmlNode = %{ $osmXmlNodesRef->{$currXmlNodeId} };
    my $databaseNodeId = $nodeIdMappingsXmlToDb{$currXmlNodeId};

    # Compare lat, lon, version, tags

    if ( $currXmlNode{'lat'} ne $currentNodesData{$nodeIdMappingsXmlToDb{$currXmlNodeId}}->{'lat'} )
    {
      print( "ERROR: XML node $currXmlNodeId latitude $currXmlNode{'lat'} != " .
        "DB node $nodeIdMappingsXmlToDb{$currXmlNodeId} lat " . 
        $currentNodesData{$nodeIdMappingsXmlToDb{$currXmlNodeId}}->{'lat'} . "\n\n" );
      exit;
    }
  
    if ( $currXmlNode{'lon'} ne $currentNodesData{$nodeIdMappingsXmlToDb{$currXmlNodeId}}->{'lon'} )
    {
      print( "ERROR: XML node $currXmlNodeId longitude $currXmlNode{'lon'} != " .
        "DB node $nodeIdMappingsXmlToDb{$currXmlNodeId} lon " .
        $currentNodesData{$nodeIdMappingsXmlToDb{$currXmlNodeId}}->{'lon'} . "\n\n" );
      exit;
    }

    # Version -- as this is a new ingest, must be v1 in database
    if ( $currentNodesData{$nodeIdMappingsXmlToDb{$currXmlNodeId}}->{'version'} != 1 )
    {
      print("XML node $currXmlNodeId with database node ID " .
          $nodeIdMappingsXmlToDb{$currXmlNodeId} . " is not version 1 which it should be after " .
          "being newly-inserted into a fresh database\n" );
      exit;
    }

    # Tags
    if ( exists($currXmlNode{'tag'}) )
    {
      #print( "XML Tags: " . Dumper($currXmlNode{'tag'}) . "\n");
      #print( "DB tags: " . Dumper($currentNodesData{$databaseNodeId}->{'tags'}) . "\n");

      my $xmlTagsArrayRef = $currXmlNode{'tag'};

      # Make sure number of tags are equal
      if ( scalar( @{$xmlTagsArrayRef} ) != 
          scalar( keys(%{ $currentNodesData{$databaseNodeId}->{'tags'} })) )
      {
        print("ERROR: number of tags in XML for node $currXmlNodeId " .
          "does not match database node $nodeIdMappingsXmlToDb{$currXmlNodeId}\n");
        exit;
      }

      my $currTag;

      foreach $currTag ( @{$xmlTagsArrayRef} )
      {
        my %xmlTagEntry = %{ $currTag };
        #print( "Key   : $tagEntry{'k'}\n");
        #print( "Value : $tagEntry{'v'}\n");

        my %dbTagEntry = %{ $currentNodesData{$databaseNodeId}->{'tags'} };
        if ( ! exists( $dbTagEntry{ $xmlTagEntry{'k'} } ) )
        {
          print("Could not find database version of tag " . Dumper(%xmlTagEntry) . "\n" ); 
          exit;
        }
        else
        {
          #print("XML tag: $xmlTagEntry{'k'} => $xmlTagEntry{'v'}\n");
          #print(" DB tag: $xmlTagEntry{'k'} => $dbTagEntry{ $xmlTagEntry{'k'}}\n");
        }
      }
    }
    else
    {
      # Confirm database does not have tags either
      if ( exists($currentNodesData{$databaseNodeId}->{'tags'}) )     
      {
        print( "XML did not have tags for node $currXmlNodeId, but matching " .
          "database node $databaseNodeId did!\n" );
        exit;
      }
    }
  }

  # If we made it this far, current_nodes and current_node_tags are 100% correct to XML
  print("\t\tDeep inspection of data integrity: PASS\n");
  
}

sub validateNodes($$)
{
  my $osmXmlNodesRef = shift(@_);
  my $dumpLinesRef = shift(@_);

  my @dumpLines = @{$dumpLinesRef};

  my %nodesData;

  my $currLine;

  # Checking table: nodes
  print( "\tnodes, node_tags:\n");
  my $foundStart = 0;
  foreach $currLine (@dumpLines)
  {
    chomp($currLine);

    # Find out where nodes starts
    if ( $foundStart == 0 )
    {
      if ($currLine =~ /^COPY nodes \(.+\) FROM stdin;/ )
      {
        $foundStart = 1;
      }

      # Either way, can't do any more processing
      next;
    }

    # Are we at end of data?
    if ( $currLine =~ /^\\./ )
    {
      last;
    }

    #print( "Current_nodes entry: $currLine\n" );

    # Have a valid node
    my %nodesEntry;

    # Break into tokens based on tab delimiter
    # Schema: id, latitude, longitude, changeset_id, visible, "timestamp", tile, version
    my @tokens = split( /\s+/, $currLine);

    #print( "Found node, ID = $tokens[0]\n");

    $nodesEntry{'lat'} = convertNanodegreesStringToDegrees($tokens[1]);
    #print( "\tSource string: $tokens[1]\n");
    #print( "\tConverted latitude: $nodesEntry{'lat'}\n");

    $nodesEntry{'lon'} = convertNanodegreesStringToDegrees($tokens[2]);
    #print( "\tLongitude: $nodesEntry{'lon'}\n");

    $nodesEntry{'tile_num'} = $tokens[7];
    $nodesEntry{'version'} = $tokens[8];

    #print( "\tCoords (lat/lon): $nodesEntry{'lat'}, $nodesEntry{'lon'}\n");
    #print( "\tTile: $nodesEntry{'tile_num'}\n");
    #print( "\tVersion: $nodesEntry{'version'}\n");

    # Store the entry in hash of nodes
    $nodesData{$tokens[0]} = \%nodesEntry;
  }

  #print( 'Found ' . scalar(keys(%nodesData)) . " entries in nodes\n" );

  # Read node_tags

  $foundStart = 0;
  foreach $currLine (@dumpLines)
  {
    chomp($currLine);

    # Find out where table data starts
    if ( $foundStart == 0 )
    {
      if ($currLine =~ /^COPY node_tags \(.+\) FROM stdin;/ )
      {
        $foundStart = 1;
      }

      # Either way, can't do any more processing
      next;
    }

    # Are we at end of data?
    if ( $currLine =~ /^\\./ )
    {
      last;
    }

    #print( "node_tags entry: $currLine\n" );

    # Have a valid node
    my %nodeTagsEntry;

    # Break into tokens based on tab delimiter
    # Schema: node_id, version, key, value
    my @tokens = split( /\t+/, $currLine);

    #print( "Found node tag\n");

    $nodeTagsEntry{$tokens[2]} = $tokens[3];
    #print( "\tID: $tokens[0]\n\tKey: $tokens[2]\n\tValue: $tokens[3]\n");

    # Store the entry in hash of nodes
    if ( exists($nodesData{ $tokens[0] }->{'tags'} ) )
    {
      $nodesData{ $tokens[0] }->{'tags'}->{$tokens[2]} = $tokens[3];

      #my $key;
      #foreach $key ( keys( $nodesData{ $tokens[0] }->{'tags'}) )
      #{
      # print( "\tFound tags key: $key\n" );
      #}
    }
    else
    {
      $nodesData{ $tokens[0] }->{'tags'} = { $tokens[2] => $tokens[3] };
    }
  }

  # First sanity check: make sure # of OSM nodes exactly matches # of OSM API DB nodes
  #print( "Number of OSM nodes: " . scalar(keys(%$osmXmlNodesRef)) . "\n" );
  if ( scalar(keys(%$osmXmlNodesRef)) != scalar(keys(%nodesData)) )
  {
    print('ERROR: OSM XML nodes: ' . scalar(keys(%$osmXmlNodesRef)) .
      ' != OSM API DB nodes: ' . scalar(keys(%nodesData)) . "\n\n" );

    exit;
  }

  print( "\t\tMatching number of nodes: PASS (" .
    scalar(keys(%nodesData)) . ")\n");

  # Now let's create mapping for Postgres Node ID -> OSM node ID.  the OSM XML node IDs were added in 
  #   ascending node ID order, so if we iterate over OSM API node IDs in ascending, we have a guaranteed
  #   mapping

  my @sortedDbNodeIds = sort( {$a <=> $b} keys(%nodesData));
  my $currXmlNodeId;
  my $i = 0;
  foreach $currXmlNodeId ( sort( {$a <=> $b} keys(%$osmXmlNodesRef)) )
  {
    $nodeIdMappingsXmlToDb{$currXmlNodeId} = $sortedDbNodeIds[$i];

    #print("XML node ID $currXmlNodeId maps to DB node ID $sortedDbNodeIds[$i]\n");

    $i++;
  }

  # Now that we have mapping, go back and compare each XML node to corresponding entry in nodes
  foreach $currXmlNodeId ( sort( {$a <=> $b} keys(%$osmXmlNodesRef)) )
  {
    my %currXmlNode = %{ $osmXmlNodesRef->{$currXmlNodeId} };
    my $databaseNodeId = $nodeIdMappingsXmlToDb{$currXmlNodeId};

    # Compare lat, lon, version, tags

    if ( $currXmlNode{'lat'} ne $nodesData{$nodeIdMappingsXmlToDb{$currXmlNodeId}}->{'lat'} )
    {
      print( "ERROR: XML node $currXmlNodeId latitude $currXmlNode{'lat'} != " .
        "DB node $nodeIdMappingsXmlToDb{$currXmlNodeId} lat " .
        $nodesData{$nodeIdMappingsXmlToDb{$currXmlNodeId}}->{'lat'} . "\n\n" );
      exit;
    }

    if ( $currXmlNode{'lon'} ne $nodesData{$nodeIdMappingsXmlToDb{$currXmlNodeId}}->{'lon'} )
    {
      print( "ERROR: XML node $currXmlNodeId longitude $currXmlNode{'lon'} != " .
        "DB node $nodeIdMappingsXmlToDb{$currXmlNodeId} lon " .
        $nodesData{$nodeIdMappingsXmlToDb{$currXmlNodeId}}->{'lon'} . "\n\n" );
      exit;
    }

    # Version -- as this is a new ingest, must be v1 in database
    if ( $nodesData{$nodeIdMappingsXmlToDb{$currXmlNodeId}}->{'version'} != 1 )
    {
      print("XML node $currXmlNodeId with database node ID " .
          $nodeIdMappingsXmlToDb{$currXmlNodeId} . " is not version 1 which it should be after " .
          "being newly-inserted into a fresh database\n" );
      exit;
    }

    # Tags
    if ( exists($currXmlNode{'tag'}) )
    {
      #print( "XML Tags: " . Dumper($currXmlNode{'tag'}) . "\n");
      #print( "DB tags: " . Dumper($nodesData{$databaseNodeId}->{'tags'}) . "\n");

      my $xmlTagsArrayRef = $currXmlNode{'tag'};

      # Make sure number of tags are equal
      if ( scalar( @{$xmlTagsArrayRef} ) !=
          scalar( keys(%{ $nodesData{$databaseNodeId}->{'tags'} })) )
      {
        print("ERROR: number of tags in XML for node $currXmlNodeId " .
          "does not match database node $nodeIdMappingsXmlToDb{$currXmlNodeId}\n");
        exit;
      }


      my $currTag;

      foreach $currTag ( @{$xmlTagsArrayRef} )
      {
        my %xmlTagEntry = %{ $currTag };
        #print( "Key   : $tagEntry{'k'}\n");
        #print( "Value : $tagEntry{'v'}\n");

        my %dbTagEntry = %{ $nodesData{$databaseNodeId}->{'tags'} };
        if ( ! exists( $dbTagEntry{ $xmlTagEntry{'k'} } ) )
        {
          print("Could not find database version of tag " . Dumper(%xmlTagEntry) . "\n" );
          exit;
        }
        else
        {
          #print("XML tag: $xmlTagEntry{'k'} => $xmlTagEntry{'v'}\n");
          #print(" DB tag: $xmlTagEntry{'k'} => $dbTagEntry{ $xmlTagEntry{'k'}}\n");
        }
      }
    }
    else
    {
      # Confirm database does not have tags either
      if ( exists($nodesData{$databaseNodeId}->{'tags'}) )     
      {
        print( "XML did not have tags for node $currXmlNodeId, but matching " .
          "database node $databaseNodeId did!\n" );
        exit;
      }
    }

  }

  # If we made it this far, nodes and node_tags are 100% correct to XML
  print("\t\tDeep inspection of data integrity: PASS\n");
}

sub validateOsmXmlWays($$)
{
  my $osmXmlWaysRef = shift(@_);
  my $dumpLinesRef = shift(@_);

  print("\nValidating data: ways\n");

  validateCurrentWays($osmXmlWaysRef, $dumpLinesRef);
  validateWays($osmXmlWaysRef, $dumpLinesRef);
}

sub validateCurrentWays($$)
{
  my $osmXmlWaysRef = shift(@_);
  my $dumpLinesRef = shift(@_);

  my @dumpLines = @{$dumpLinesRef};

  my %currentWaysData;

  my $currLine;

  # Checking table: current_ways
  print( "\tcurrent_ways, current_way_tags, current_way_nodes:\n");
  my $foundStart = 0;
  foreach $currLine (@dumpLines)
  {
    chomp($currLine);

    # Find out where current_ways starts
    if ( $foundStart == 0 )
    {
      if ($currLine =~ /^COPY current_ways \(.+\) FROM stdin;/ )
      {
        $foundStart = 1;
      }

      # Either way, can't do any more processing
      next;
    }

    # Are we at end of data?
    if ( $currLine =~ /^\\./ )
    {
      last;
    }

    #print( "Current_ways entry: $currLine\n" );

    # Have a valid way
    my %currentWaysEntry;

    # Break into tokens based on tab delimiter
    # Schema: id, changeset_id, "timestamp", visible, version
    my @tokens = split( /\s+/, $currLine);

    #print( "Found way, ID = $tokens[0]\n");

    $currentWaysEntry{'version'} = $tokens[5];

    # Store the entry in hash of current_ways_
    $currentWaysData{$tokens[0]} = \%currentWaysEntry;
  }

  #print( 'Found ' . scalar(keys(%currentWaysData)) . " entries in current_ways\n" );

  # First sanity check: make sure # of OSM ways exactly matches # of OSM API DB ways
  #print( "Number of OSM ways: " . scalar(keys(%$osmXmlWaysRef)) . "\n" );
  if ( scalar(keys(%$osmXmlWaysRef)) != scalar(keys(%currentWaysData)) )
  {
    print('ERROR: OSM XML ways: ' . scalar(keys(%$osmXmlWaysRef)) .
      ' != OSM API DB ways: ' . scalar(keys(%currentWaysData)) . "\n\n" );

    exit;
  }

  print( "\t\tMatching number of ways: PASS (" .
    scalar(keys(%currentWaysData)) . ")\n" );

  # Read current_way_tags

  $foundStart = 0;
  foreach $currLine (@dumpLines)
  {
    chomp($currLine);

    # Find out where table data starts
    if ( $foundStart == 0 )
    {
      if ($currLine =~ /^COPY current_way_tags \(.+\) FROM stdin;/ )
      {
        $foundStart = 1;
      }

      # Either way, can't do any more processing
      next;
    }

    # Are we at end of data?
    if ( $currLine =~ /^\\./ )
    {
      last;
    }

    #print( "Current_way_tags entry: $currLine\n" );

    # Have a valid way
    my %currentWayTagsEntry;

    # Break into tokens based on tab delimiter
    # Schema: way_id, key, value
    my @tokens = split( /\t+/, $currLine);

    #print( "Found way tag\n");

    $currentWayTagsEntry{$tokens[1]} = $tokens[2];
    #print( "\tID: $tokens[0]\n\tKey: $tokens[1]\n\tValue: $tokens[2]\n");

    # Store the entry in hash of current_ways
    if ( exists($currentWaysData{ $tokens[0] }->{'tags'} ) )
    {
      $currentWaysData{ $tokens[0] }->{'tags'}->{$tokens[1]} = $tokens[2];

      #my $key;
      #foreach $key ( keys( $currentNodesData{ $tokens[0] }->{'tags'}) )
      #{
      # print( "\tFound tags key: $key\n" );
      #}
    }
    else
    {
      $currentWaysData{ $tokens[0] }->{'tags'} = { $tokens[1] => $tokens[2] };
    }
  }

  # Read current_way_nodes
  $foundStart = 0;
  foreach $currLine (@dumpLines)
  {
    chomp($currLine);

    # Find out where table data starts
    if ( $foundStart == 0 )
    {
      if ($currLine =~ /^COPY current_way_nodes \(.+\) FROM stdin;/ )
      {
        $foundStart = 1;
      }

      # Either way, can't do any more processing
      next;
    }

    # Are we at end of data?
    if ( $currLine =~ /^\\./ )
    {
      last;
    }

    #print( "Current_way_nodes entry: $currLine\n" );

    # Have valid way nodes
    my %currentWayNodeEntry;

    # Break into tokens based on tab delimiter
    # Schema: way_id, node_id, sequence_id
    my @tokens = split( /\t+/, $currLine);

    #print( "Found current_way_node\n");

    #print( "\tID: $tokens[0]\n\tKey: $tokens[1]\n\tValue: $tokens[2]\n");

    # Store the entry in hash of nodes in this way
    if ( exists($currentWaysData{ $tokens[0] }->{'way_nodes'} ) )
    {
      $currentWaysData{ $tokens[0] }->{'way_nodes'}->{$tokens[2]} = $tokens[1];

      my $way_node;
      foreach $way_node ( sort( {$a <=> $b} keys( %{ $currentWaysData{ $tokens[0] }->{'way_nodes'}})) )
      {
        print( "\tFound node for way $tokens[0]: seq $way_node = node " .
          $currentWaysData{ $tokens[0] }->{'way_nodes'}->{$way_node} . "\n");
      }
    }
    else
    {
      $currentWaysData{ $tokens[0] }->{'way_nodes'} = { $tokens[2] => $tokens[1] };
    }
  }


  # Now let's create mapping for Postgres way ID -> OSM way ID.  the OSM XML way IDs were added in 
  #   ascending way ID order, so if we iterate over OSM API way IDs in ascending, we have a guaranteed
  #   mapping

  my @sortedDbWayIds = sort( {$a <=> $b} keys(%currentWaysData));
  my $currXmlWayId;
  my $i = 0;
  foreach $currXmlWayId ( sort( {$a <=> $b} keys(%$osmXmlWaysRef)) )
  {
    $wayIdMappingsXmlToDb{$currXmlWayId} = $sortedDbWayIds[$i];

    #print("XML way ID $currXmlWayId maps to DB way ID $sortedDbWayIds[$i]\n");

    $i++;
  }

  # Now that we have mapping, go back and compare each XML way to corresponding entry in current_ways
  foreach $currXmlWayId ( sort( {$a <=> $b} keys(%$osmXmlWaysRef)) )
  {
    my %currXmlWay = %{ $osmXmlWaysRef->{$currXmlWayId} };
    my $databaseWayId = $wayIdMappingsXmlToDb{$currXmlWayId};

    # Check version, tags

    # Version -- as this is a new ingest, must be v1 in database
    if ( $currentWaysData{$wayIdMappingsXmlToDb{$currXmlWayId}}->{'version'} != 1 )
    {
      print("XML way $currXmlWayId with database way ID " .
          $wayIdMappingsXmlToDb{$currXmlWayId} . " is not version 1 which it should be after " .
          "being newly-inserted into a fresh database\n" );
      exit;
    }

    # Tags
    if ( exists($currXmlWay{'tag'}) )
    {
      #print( "XML Tags: " . Dumper($currXmlWay{'tag'}) . "\n");
      #print( "DB tags: " . Dumper($currentWaysData{$databaseWayId}->{'tags'}) . "\n");

      my $xmlTagsArrayRef = $currXmlWay{'tag'};

      # Make sure number of tags are equal
      if ( scalar( @{$xmlTagsArrayRef} ) !=
          scalar( keys(%{ $currentWaysData{$databaseWayId}->{'tags'} })) )
      {
        print("ERROR: number of tags in XML for way $currXmlWayId " .
          "does not match database way $wayIdMappingsXmlToDb{$currXmlWayId}\n");
        exit;
      }

      my $currTag;

      foreach $currTag ( @{$xmlTagsArrayRef} )
      {
        my %xmlTagEntry = %{ $currTag };
        #print( "Key   : $tagEntry{'k'}\n");
        #print( "Value : $tagEntry{'v'}\n");

        my %dbTagEntry = %{ $currentWaysData{$databaseWayId}->{'tags'} };
        if ( ! exists( $dbTagEntry{ $xmlTagEntry{'k'} } ) )
        {
          print("Could not find database version of tag " . Dumper(%xmlTagEntry) . "\n" );
          exit;
        }
        else
        {
          #print("XML tag: $xmlTagEntry{'k'} => $xmlTagEntry{'v'}\n");
          #print(" DB tag: $xmlTagEntry{'k'} => $dbTagEntry{ $xmlTagEntry{'k'}}\n");
        }
      }
    }
    else
    {
      # Confirm database does not have tags either
      if ( exists($currentWaysData{$databaseWayId}->{'tags'}) )     
      {
        print( "XML did not have tags for way $currXmlWayId, but matching " .
          "database way $databaseWayId did!\n" );
        exit;
      }
    }

    # way_nodes 
    if ( exists($currXmlWay{'nd'}) )
    {
      
    }
    else
    {
      #print("Found an XML way with no nodes: $currXmlWayId\n");

      # Confirm database does not have nodes for this way either
      if ( exists( $currentWaysData{$databaseWayId}->{'nd'}) )
      {
        
      }
    }
  }

  # If we made it this far, current_ways and current_way_tags are 100% correct to XML
  print("\t\tDeep inspection of data integrity: PASS\n");

}


  


sub validateWays($$)
{
  ;
}




if ( scalar(@ARGV) != 2 ) 
{
  print( "Usage: compareOsmXmlToPgsqlDump <OSM XML file> <PostgreSQL pg_dump output file>\n\n");
  exit;
}

my $osmXmlFile = $ARGV[0];
my $pgsqlDumpFile = $ARGV[1];

open(XMLFILE, "< $osmXmlFile");
my @xmlLines = <XMLFILE>;
close(XMLFILE);

open(PGDUMPFILE, "< $pgsqlDumpFile" );
my @dumpLines = <PGDUMPFILE>;
close(PGDUMPFILE);

# Concat the XML contents into one string for parsing
my $concatOsmXml = join('', @xmlLines);

print( "OSM XML file:\t\t$osmXmlFile\nPostgreSQL dump file:\t$pgsqlDumpFile\n\n");

# Create XML parser
my $xs = XML::Simple->new();

my $domRef = createOsmDom($xs, $concatOsmXml);
validateOsmXmlNodes($domRef->{node}, \@dumpLines );
validateOsmXmlWays($domRef->{way}, \@dumpLines );

