#!/usr/bin/perl -w

# Compare the contents of an OSM XML file to a database dump (created with pg_dump) 
# of an OSM API database after that OSM XML file has been uploaded to it
#
# NOTE: this script requires the Perl module "XML::Simple" to be installed
#
# On Ubuntu 14.04, this can be installed using the following:
#
#     sudo apt-get install libxml-simple-perl

use strict;
use Encode;
require XML::Simple;

use XML::Simple qw(:strict);
use Data::Dumper;

sub createOsmDom($$);
sub readXmlToDbIdMappings($$);
sub validateOsmXmlNodes($$);
sub validateCurrentNodes($$);
sub validateNodes($$);
sub validateOsmXmlWays($$);
sub validateCurrentWays($$);
sub validateWays($$);
sub validateOsmXmlRelations($$$);
sub validateCurrentRelations($$$);
sub validateRelations($$$);

sub convertNanodegreesStringToDegrees($);

# Globals for data
my %nodesOsm;
my %nodesPgsql;
my %nodeIdMappingsXmlToDb;
my %wayIdMappingsXmlToDb;
my %relationIdMappingsXmlToDb;

sub convertNanodegreesStringToDegrees($)
{
  #my $nanodegreesString = shift(@_);
  #print( "\tInput nanodegree string: $nanodegreesString\n");

  #my $nanodegrees = ($nanodegreesString * 1.0);

  #my $degrees = ( $nanodegrees / 10000000.0 );
  #print( "\tComputed degrees: $degrees\n\n");
  #return $degrees;

  return ( shift(@_) / 10000000.0 );
}

sub createOsmDom($$)
{
  my $xs = shift(@_);
  my $xmlString = shift(@_);

  my $domRef = $xs->XMLin($xmlString, 
    KeyAttr => { node => 'id', way => 'id', relation=> 'id' }, 
    ForceArray => [ 'node', 'tag', 'way', 'nd', 'relation', 'member' ],
    ValueAttr => ['ref'] 
  );

  return $domRef;
}

sub validateOsmXmlNodes($$)
{
  my $osmXmlNodesRef = shift(@_);
  my $dumpLinesRef = shift(@_);

  print("Validating data: nodes\n");

  validateCurrentNodes($osmXmlNodesRef, $dumpLinesRef);
  validateNodes($osmXmlNodesRef, $dumpLinesRef);
}

sub validateCurrentNodes($$)
{
  my $osmXmlNodesRef = shift(@_);
  my $dumpLinesRef = shift(@_);

  my @dumpLines = @{$dumpLinesRef};

  my %currentNodesData;

  my $currLine;

  # Checking table: current_nodes
  print( "\tcurrent_nodes, current_node_tags:\n");
  my $foundStart = 0;
  foreach $currLine (@dumpLines)
  {
    chomp($currLine);

    # UTF8 decoding for non-western character sets
    $currLine = decode_utf8($currLine);

    # Find out where current_nodes starts
    if ( $foundStart == 0 ) 
    {
      if ($currLine =~ /^COPY current_nodes .+ FROM stdin;/ )
      {
        $foundStart = 1;
      }

      # Either way, can't do any more processing
      next;
    }

    # Are we at end of data?
    if ( $currLine =~ /^\\./ )
    {
      last;
    }

    #print( "Current_nodes entry: $currLine\n" );

    # Have a valid node
    my %currentNodesEntry;

    # Break into tokens based on tab delimiter
    # Schema: id, latitude, longitude, changeset_id, visible, "timestamp", tile, version
    my @tokens = split( /\s+/, $currLine);

    #print( "Found node, ID = $tokens[0]\n");
  
    $currentNodesEntry{'lat'} = convertNanodegreesStringToDegrees($tokens[1]);
    #print( "\tSource string: $tokens[1]\n");
    #print( "\tConverted latitude: $currentNodesEntry{'lat'}\n");

    $currentNodesEntry{'lon'} = convertNanodegreesStringToDegrees($tokens[2]);
    #print( "\tLongitude: $currentNodesEntry{'lon'}\n");

    $currentNodesEntry{'tile_num'} = $tokens[7];
    $currentNodesEntry{'version'} = $tokens[8];

    #print( "\tCoords (lat/lon): $currentNodesEntry{'lat'}, $currentNodesEntry{'lon'}\n");
    #print( "\tTile: $currentNodesEntry{'tile_num'}\n");
    #print( "\tVersion: $currentNodesEntry{'version'}\n");

    # Store the entry in hash of current_nodes
    $currentNodesData{$tokens[0]} = \%currentNodesEntry;
  }

  #print( 'Found ' . scalar(keys(%currentNodesData)) . " entries in current_nodes\n" );

  # Read current_node_tags

  $foundStart = 0;
  foreach $currLine (@dumpLines)
  {
    chomp($currLine);

    # UTF8 decoding for non-western character sets
    $currLine = decode_utf8($currLine);

    # Find out where table data starts
    if ( $foundStart == 0 )
    {
      if ($currLine =~ /^COPY current_node_tags .+ FROM stdin;/ )
      {
        $foundStart = 1;
      }

      # Either way, can't do any more processing
      next;
    }

    # Are we at end of data?
    if ( $currLine =~ /^\\./ )
    {
      last;
    }

    #print( "Current_node_tags entry: $currLine\n" );

    # Have a valid node
    my %currentNodeTagsEntry;

    # Break into tokens based on tab delimiter
    # Schema: node_id, key, value
    my @tokens = split( /\t+/, $currLine);

    #print( "Found node tag\n");

    $currentNodeTagsEntry{$tokens[1]} = $tokens[2];
    #print( "\tID: $tokens[0]\n\tKey: $tokens[1]\n\tValue: $tokens[2]\n");

    # Store the entry in hash of current_nodes
    if ( exists($currentNodesData{ $tokens[0] }->{'tags'} ) )
    {
      $currentNodesData{ $tokens[0] }->{'tags'}->{$tokens[1]} = $tokens[2];

      #my $key;
      #foreach $key ( keys( $currentNodesData{ $tokens[0] }->{'tags'}) )
      #{
      # print( "\tFound tags key: $key\n" );
      #}
    }
    else
    {
      $currentNodesData{ $tokens[0] }->{'tags'} = { $tokens[1] => $tokens[2] };
    }
  }

  # First sanity check: make sure # of OSM current_nodes exactly matches # of OSM API DB current_nodes
  #print( "Number of OSM nodes: " . scalar(keys(%$osmXmlNodesRef)) . "\n" );
  if ( scalar(keys(%$osmXmlNodesRef)) != scalar(keys(%currentNodesData)) )
  {
    print('ERROR: OSM XML nodes: ' . scalar(keys(%$osmXmlNodesRef)) .
      ' != OSM API DB nodes: ' . scalar(keys(%currentNodesData)) . "\n\n" );

    exit;
  }
  
  print( "\t\tMatching number of nodes: PASS (" . 
    scalar(keys(%currentNodesData)) . ")\n");

  # Now that we have mapping, go back and compare each XML node to corresponding entry in current_nodes
  my $currXmlNodeId;
  foreach $currXmlNodeId ( sort( {$a <=> $b} keys(%$osmXmlNodesRef)) )
  {
    my %currXmlNode = %{ $osmXmlNodesRef->{$currXmlNodeId} };
    my $databaseNodeId = $nodeIdMappingsXmlToDb{$currXmlNodeId};

    # Compare lat, lon, version, tags

    if ( $currXmlNode{'lat'} ne $currentNodesData{$nodeIdMappingsXmlToDb{$currXmlNodeId}}->{'lat'} )
    {
      print( "ERROR: XML node $currXmlNodeId latitude $currXmlNode{'lat'} != " .
        "DB node $nodeIdMappingsXmlToDb{$currXmlNodeId} lat " . 
        $currentNodesData{$nodeIdMappingsXmlToDb{$currXmlNodeId}}->{'lat'} . "\n\n" );
      exit;
    }
  
    if ( $currXmlNode{'lon'} ne $currentNodesData{$nodeIdMappingsXmlToDb{$currXmlNodeId}}->{'lon'} )
    {
      print( "ERROR: XML node $currXmlNodeId longitude $currXmlNode{'lon'} != " .
        "DB node $nodeIdMappingsXmlToDb{$currXmlNodeId} lon " .
        $currentNodesData{$nodeIdMappingsXmlToDb{$currXmlNodeId}}->{'lon'} . "\n\n" );
      exit;
    }

    # Version -- as this is a new ingest, must be v1 in database
    if ( $currentNodesData{$nodeIdMappingsXmlToDb{$currXmlNodeId}}->{'version'} != 1 )
    {
      print("XML node $currXmlNodeId with database node ID " .
          $nodeIdMappingsXmlToDb{$currXmlNodeId} . " is not version 1 which it should be after " .
          "being newly-inserted into a fresh database\n" );
      exit;
    }

    # Tags
    if ( exists($currXmlNode{'tag'}) )
    {
      #print( "XML Tags: " . Dumper($currXmlNode{'tag'}) . "\n");
      #print( "DB tags: " . Dumper($currentNodesData{$databaseNodeId}->{'tags'}) . "\n");

      my $xmlTagsArrayRef = $currXmlNode{'tag'};

      # Make sure number of tags are equal
      if ( scalar( @{$xmlTagsArrayRef} ) != 
          scalar( keys(%{ $currentNodesData{$databaseNodeId}->{'tags'} })) )
      {
        print("ERROR: number of tags in XML for node $currXmlNodeId " .
          "does not match database node $nodeIdMappingsXmlToDb{$currXmlNodeId}\n");
        exit;
      }

      my $currTag;

      foreach $currTag ( @{$xmlTagsArrayRef} )
      {
        my %xmlTagEntry = %{ $currTag };
        #print( "Key   : $tagEntry{'k'}\n");
        #print( "Value : $tagEntry{'v'}\n");

        my %dbTagEntry = %{ $currentNodesData{$databaseNodeId}->{'tags'} };
        
        if ( ! exists( $dbTagEntry{ $xmlTagEntry{'k'} } ) )
        {
          print("Could not find database version of tag " . Dumper(%xmlTagEntry) . "\n" ); 
          exit;
        }
        else
        {
          #print("XML tag: $xmlTagEntry{'k'} => $xmlTagEntry{'v'}\n");
          #print(" DB tag: $xmlTagEntry{'k'} => $dbTagEntry{ $xmlTagEntry{'k'}}\n");

          if ( $xmlTagEntry{'v'} ne $dbTagEntry{ $xmlTagEntry{'k'}} )
          {
            print( "Tag values do not match for node XML $currXmlNodeId, " .
              "database node $databaseNodeId, key = $xmlTagEntry{'k'}, " .
              "XML = " . $xmlTagEntry{'v'} . ", DB = " .
              $dbTagEntry{ $xmlTagEntry{'k'} } . "\n");

            exit;
          }
          else
          {
            #print( "Data match on key $xmlTagEntry{'k'}\n");
            #print( "\tXML (UTF8): $xmlUtf8\n\tDB (UTF8): $dbUtf8\n");
          }
        }
      }
    }
    else
    {
      # Confirm database does not have tags either
      if ( exists($currentNodesData{$databaseNodeId}->{'tags'}) )     
      {
        print( "XML did not have tags for node $currXmlNodeId, but matching " .
          "database node $databaseNodeId did!\n" );
        exit;
      }
    }
  }

  # If we made it this far, current_nodes and current_node_tags are 100% correct to XML
  print("\t\tDeep inspection of data integrity: PASS\n");
  
}

sub validateNodes($$)
{
  my $osmXmlNodesRef = shift(@_);
  my $dumpLinesRef = shift(@_);

  my @dumpLines = @{$dumpLinesRef};

  my %nodesData;

  my $currLine;

  # Checking table: nodes
  print( "\tnodes, node_tags:\n");
  my $foundStart = 0;
  foreach $currLine (@dumpLines)
  {
    chomp($currLine);

    # UTF8 decoding for non-western character sets
    $currLine = decode_utf8($currLine);

    # Find out where nodes starts
    if ( $foundStart == 0 )
    {
      if ($currLine =~ /^COPY nodes \(.+\) FROM stdin;/ )
      {
        $foundStart = 1;
      }

      # Either way, can't do any more processing
      next;
    }

    # Are we at end of data?
    if ( $currLine =~ /^\\./ )
    {
      last;
    }

    #print( "Current_nodes entry: $currLine\n" );

    # Have a valid node
    my %nodesEntry;

    # Break into tokens based on tab delimiter
    # Schema: id, latitude, longitude, changeset_id, visible, "timestamp", tile, version
    my @tokens = split( /\s+/, $currLine);

    #print( "Found node, ID = $tokens[0]\n");

    $nodesEntry{'lat'} = convertNanodegreesStringToDegrees($tokens[1]);
    #print( "\tSource string: $tokens[1]\n");
    #print( "\tConverted latitude: $nodesEntry{'lat'}\n");

    $nodesEntry{'lon'} = convertNanodegreesStringToDegrees($tokens[2]);
    #print( "\tLongitude: $nodesEntry{'lon'}\n");

    $nodesEntry{'tile_num'} = $tokens[7];
    $nodesEntry{'version'} = $tokens[8];

    #print( "\tCoords (lat/lon): $nodesEntry{'lat'}, $nodesEntry{'lon'}\n");
    #print( "\tTile: $nodesEntry{'tile_num'}\n");
    #print( "\tVersion: $nodesEntry{'version'}\n");

    # Store the entry in hash of nodes
    $nodesData{$tokens[0]} = \%nodesEntry;
  }

  #print( 'Found ' . scalar(keys(%nodesData)) . " entries in nodes\n" );

  # Read node_tags

  $foundStart = 0;
  foreach $currLine (@dumpLines)
  {
    chomp($currLine);

    # UTF8 decoding for non-western character sets
    $currLine = decode_utf8($currLine);

    # Find out where table data starts
    if ( $foundStart == 0 )
    {
      if ($currLine =~ /^COPY node_tags \(.+\) FROM stdin;/ )
      {
        $foundStart = 1;
      }

      # Either way, can't do any more processing
      next;
    }

    # Are we at end of data?
    if ( $currLine =~ /^\\./ )
    {
      last;
    }

    #print( "node_tags entry: $currLine\n" );

    # Have a valid node
    my %nodeTagsEntry;

    # Break into tokens based on tab delimiter
    # Schema: node_id, version, key, value
    my @tokens = split( /\t+/, $currLine);

    #print( "Found node tag\n");

    $nodeTagsEntry{$tokens[2]} = $tokens[3];
    #print( "\tID: $tokens[0]\n\tKey: $tokens[2]\n\tValue: $tokens[3]\n");

    # Store the entry in hash of nodes
    if ( exists($nodesData{ $tokens[0] }->{'tags'} ) )
    {
      $nodesData{ $tokens[0] }->{'tags'}->{$tokens[2]} = $tokens[3];

      #my $key;
      #foreach $key ( keys( $nodesData{ $tokens[0] }->{'tags'}) )
      #{
      # print( "\tFound tags key: $key\n" );
      #}
    }
    else
    {
      $nodesData{ $tokens[0] }->{'tags'} = { $tokens[2] => $tokens[3] };
    }
  }

  # First sanity check: make sure # of OSM nodes exactly matches # of OSM API DB nodes
  #print( "Number of OSM nodes: " . scalar(keys(%$osmXmlNodesRef)) . "\n" );
  if ( scalar(keys(%$osmXmlNodesRef)) != scalar(keys(%nodesData)) )
  {
    print('ERROR: OSM XML nodes: ' . scalar(keys(%$osmXmlNodesRef)) .
      ' != OSM API DB nodes: ' . scalar(keys(%nodesData)) . "\n\n" );

    exit;
  }

  print( "\t\tMatching number of nodes: PASS (" .
    scalar(keys(%nodesData)) . ")\n");

  # Now that we have mapping, go back and compare each XML node to corresponding entry in nodes
  my $currXmlNodeId;
  foreach $currXmlNodeId ( sort( {$a <=> $b} keys(%$osmXmlNodesRef)) )
  {
    my %currXmlNode = %{ $osmXmlNodesRef->{$currXmlNodeId} };
    my $databaseNodeId = $nodeIdMappingsXmlToDb{$currXmlNodeId};

    # Compare lat, lon, version, tags

    if ( $currXmlNode{'lat'} ne $nodesData{$nodeIdMappingsXmlToDb{$currXmlNodeId}}->{'lat'} )
    {
      print( "ERROR: XML node $currXmlNodeId latitude $currXmlNode{'lat'} != " .
        "DB node $nodeIdMappingsXmlToDb{$currXmlNodeId} lat " .
        $nodesData{$nodeIdMappingsXmlToDb{$currXmlNodeId}}->{'lat'} . "\n\n" );
      exit;
    }

    if ( $currXmlNode{'lon'} ne $nodesData{$nodeIdMappingsXmlToDb{$currXmlNodeId}}->{'lon'} )
    {
      print( "ERROR: XML node $currXmlNodeId longitude $currXmlNode{'lon'} != " .
        "DB node $nodeIdMappingsXmlToDb{$currXmlNodeId} lon " .
        $nodesData{$nodeIdMappingsXmlToDb{$currXmlNodeId}}->{'lon'} . "\n\n" );
      exit;
    }

    # Version -- as this is a new ingest, must be v1 in database
    if ( $nodesData{$nodeIdMappingsXmlToDb{$currXmlNodeId}}->{'version'} != 1 )
    {
      print("XML node $currXmlNodeId with database node ID " .
          $nodeIdMappingsXmlToDb{$currXmlNodeId} . " is not version 1 which it should be after " .
          "being newly-inserted into a fresh database\n" );
      exit;
    }

    # Tags
    if ( exists($currXmlNode{'tag'}) )
    {
      #print( "XML Tags: " . Dumper($currXmlNode{'tag'}) . "\n");
      #print( "DB tags: " . Dumper($nodesData{$databaseNodeId}->{'tags'}) . "\n");

      my $xmlTagsArrayRef = $currXmlNode{'tag'};

      # Make sure number of tags are equal
      if ( scalar( @{$xmlTagsArrayRef} ) !=
          scalar( keys(%{ $nodesData{$databaseNodeId}->{'tags'} })) )
      {
        print("ERROR: number of tags in XML for node $currXmlNodeId " .
          "does not match database node $nodeIdMappingsXmlToDb{$currXmlNodeId}\n");
        exit;
      }


      my $currTag;

      foreach $currTag ( @{$xmlTagsArrayRef} )
      {
        my %xmlTagEntry = %{ $currTag };
        #print( "Key   : $tagEntry{'k'}\n");
        #print( "Value : $tagEntry{'v'}\n");

        my %dbTagEntry = %{ $nodesData{$databaseNodeId}->{'tags'} };
        if ( ! exists( $dbTagEntry{ $xmlTagEntry{'k'} } ) )
        {
          print("Could not find database version of tag " . Dumper(%xmlTagEntry) . "\n" );
          exit;
        }
        else
        {
          #print("XML tag: $xmlTagEntry{'k'} => $xmlTagEntry{'v'}\n");
          #print(" DB tag: $xmlTagEntry{'k'} => $dbTagEntry{ $xmlTagEntry{'k'}}\n");

          if ( $xmlTagEntry{'v'} ne $dbTagEntry{ $xmlTagEntry{'k'}} )
          {
            print( "Tag values do not match for node XML $currXmlNodeId, " .
              "database relation $databaseNodeId, key = $xmlTagEntry{'k'}, " .
              "XML = " . $xmlTagEntry{'v'} . ", DB = " .
              $dbTagEntry{ $xmlTagEntry{'k'} } . "\n");

            exit;
          }
          else
          {
            #print( "Data match on key $xmlTagEntry{'k'}\n");
            #print( "\tXML (UTF8): $xmlUtf8\n\tDB (UTF8): $dbUtf8\n");

          }

        }
      }
    }
    else
    {
      # Confirm database does not have tags either
      if ( exists($nodesData{$databaseNodeId}->{'tags'}) )     
      {
        print( "XML did not have tags for node $currXmlNodeId, but matching " .
          "database node $databaseNodeId did!\n" );
        exit;
      }
    }

  }

  # If we made it this far, nodes and node_tags are 100% correct to XML
  print("\t\tDeep inspection of data integrity: PASS\n");
}

sub validateOsmXmlWays($$)
{
  my $osmXmlWaysRef = shift(@_);
  my $dumpLinesRef = shift(@_);

  print("\nValidating data: ways\n");

  validateCurrentWays($osmXmlWaysRef, $dumpLinesRef);
  validateWays($osmXmlWaysRef, $dumpLinesRef);
}

sub validateCurrentWays($$)
{
  my $osmXmlWaysRef = shift(@_);
  my $dumpLinesRef = shift(@_);

  my @dumpLines = @{$dumpLinesRef};

  my %currentWaysData;

  my $currLine;

  # Checking table: current_ways
  print( "\tcurrent_ways, current_way_tags, current_way_nodes:\n");
  my $foundStart = 0;
  foreach $currLine (@dumpLines)
  {
    chomp($currLine);

    # UTF8 decoding for non-western character sets
    $currLine = decode_utf8($currLine);

    # Find out where current_ways starts
    if ( $foundStart == 0 )
    {
      if ($currLine =~ /^COPY current_ways \(.+\) FROM stdin;/ )
      {
        $foundStart = 1;
      }

      # Either way, can't do any more processing
      next;
    }

    # Are we at end of data?
    if ( $currLine =~ /^\\./ )
    {
      last;
    }

    #print( "Current_ways entry: $currLine\n" );

    # Have a valid way
    my %currentWaysEntry;

    # Break into tokens based on tab delimiter
    # Schema: id, changeset_id, "timestamp", visible, version
    my @tokens = split( /\s+/, $currLine);

    #print( "Found way, ID = $tokens[0]\n");

    $currentWaysEntry{'version'} = $tokens[5];

    # Store the entry in hash of current_ways_
    $currentWaysData{$tokens[0]} = \%currentWaysEntry;
  }

  #print( 'Found ' . scalar(keys(%currentWaysData)) . " entries in current_ways\n" );

  # First sanity check: make sure # of OSM ways exactly matches # of OSM API DB ways
  #print( "Number of OSM ways: " . scalar(keys(%$osmXmlWaysRef)) . "\n" );
  if ( scalar(keys(%$osmXmlWaysRef)) != scalar(keys(%currentWaysData)) )
  {
    print('ERROR: OSM XML ways: ' . scalar(keys(%$osmXmlWaysRef)) .
      ' != OSM API DB ways: ' . scalar(keys(%currentWaysData)) . "\n\n" );

    exit;
  }

  print( "\t\tMatching number of ways: PASS (" .
    scalar(keys(%currentWaysData)) . ")\n" );

  # Read current_way_tags

  $foundStart = 0;
  foreach $currLine (@dumpLines)
  {
    chomp($currLine);

    # UTF8 decoding for non-western character sets
    $currLine = decode_utf8($currLine);

    # Find out where table data starts
    if ( $foundStart == 0 )
    {
      if ($currLine =~ /^COPY current_way_tags \(.+\) FROM stdin;/ )
      {
        $foundStart = 1;
      }

      # Either way, can't do any more processing
      next;
    }

    # Are we at end of data?
    if ( $currLine =~ /^\\./ )
    {
      last;
    }

    #print( "Current_way_tags entry: $currLine\n" );

    # Have a valid way
    my %currentWayTagsEntry;

    # Break into tokens based on tab delimiter
    # Schema: way_id, key, value
    my @tokens = split( /\t+/, $currLine);

    #print( "Found way tag\n");

    $currentWayTagsEntry{$tokens[1]} = $tokens[2];
    #print( "\tID: $tokens[0]\n\tKey: $tokens[1]\n\tValue: $tokens[2]\n");

    # Store the entry in hash of current_ways
    if ( exists($currentWaysData{ $tokens[0] }->{'tags'} ) )
    {
      $currentWaysData{ $tokens[0] }->{'tags'}->{$tokens[1]} = $tokens[2];

      #my $key;
      #foreach $key ( keys( $currentNodesData{ $tokens[0] }->{'tags'}) )
      #{
      # print( "\tFound tags key: $key\n" );
      #}
    }
    else
    {
      $currentWaysData{ $tokens[0] }->{'tags'} = { $tokens[1] => $tokens[2] };
    }
  }

  # Read current_way_nodes
  $foundStart = 0;
  foreach $currLine (@dumpLines)
  {
    chomp($currLine);

    # UTF8 decoding for non-western character sets
    $currLine = decode_utf8($currLine);

    # Find out where table data starts
    if ( $foundStart == 0 )
    {
      if ($currLine =~ /^COPY current_way_nodes \(.+\) FROM stdin;/ )
      {
        $foundStart = 1;
      }

      # Either way, can't do any more processing
      next;
    }

    # Are we at end of data?
    if ( $currLine =~ /^\\./ )
    {
      last;
    }

    #print( "Current_way_nodes entry: $currLine\n" );

    # Have valid way nodes
    my %currentWayNodeEntry;

    # Break into tokens based on tab delimiter
    # Schema: way_id, node_id, sequence_id
    my @tokens = split( /\t+/, $currLine);

    #print( "Found current_way_node\n");

    #print( "\tID: $tokens[0]\n\tKey: $tokens[1]\n\tValue: $tokens[2]\n");

    # Store the entry in hash of nodes in this way
    if ( exists($currentWaysData{ $tokens[0] }->{'way_nodes'} ) )
    {
      $currentWaysData{ $tokens[0] }->{'way_nodes'}->{$tokens[2]} = $tokens[1];

      #my $way_node;
      #foreach $way_node ( sort( {$a <=> $b} keys( %{ $currentWaysData{ $tokens[0] }->{'way_nodes'}})) )
      #{
      #  print( "\tFound node for way $tokens[0]: seq $way_node = node " .
      #    $currentWaysData{ $tokens[0] }->{'way_nodes'}->{$way_node} . "\n");
      #}
    }
    else
    {
      $currentWaysData{ $tokens[0] }->{'way_nodes'} = { $tokens[2] => $tokens[1] };
    }
  }


  # Now that we have mapping, go back and compare each XML way to corresponding entry in current_ways
  my $currXmlWayId;
  foreach $currXmlWayId ( sort( {$a <=> $b} keys(%$osmXmlWaysRef)) )
  {
    my %currXmlWay = %{ $osmXmlWaysRef->{$currXmlWayId} };
    my $databaseWayId = $wayIdMappingsXmlToDb{$currXmlWayId};

    # Check version, tags

    # Version -- as this is a new ingest, must be v1 in database
    if ( $currentWaysData{$wayIdMappingsXmlToDb{$currXmlWayId}}->{'version'} != 1 )
    {
      print("XML way $currXmlWayId with database way ID " .
          $wayIdMappingsXmlToDb{$currXmlWayId} . " is not version 1 which it should be after " .
          "being newly-inserted into a fresh database\n" );
      exit;
    }

    # Tags
    if ( exists($currXmlWay{'tag'}) )
    {
      #print( "XML Tags: " . Dumper($currXmlWay{'tag'}) . "\n");
      #print( "DB tags: " . Dumper($currentWaysData{$databaseWayId}->{'tags'}) . "\n");

      my $xmlTagsArrayRef = $currXmlWay{'tag'};

      # Make sure number of tags are equal
      if ( scalar( @{$xmlTagsArrayRef} ) !=
          scalar( keys(%{ $currentWaysData{$databaseWayId}->{'tags'} })) )
      {
        print("ERROR: number of tags in XML for way $currXmlWayId " .
          "does not match database way $wayIdMappingsXmlToDb{$currXmlWayId}\n");
        exit;
      }

      my $currTag;

      foreach $currTag ( @{$xmlTagsArrayRef} )
      {
        my %xmlTagEntry = %{ $currTag };
        #print( "Key   : $tagEntry{'k'}\n");
        #print( "Value : $tagEntry{'v'}\n");

        my %dbTagEntry = %{ $currentWaysData{$databaseWayId}->{'tags'} };
        if ( ! exists( $dbTagEntry{ $xmlTagEntry{'k'} } ) )
        {
          print("Could not find database version of tag " . Dumper(%xmlTagEntry) . "\n" );
          exit;
        }
        else
        {
          #print("XML tag: $xmlTagEntry{'k'} => $xmlTagEntry{'v'}\n");
          #print(" DB tag: $xmlTagEntry{'k'} => $dbTagEntry{ $xmlTagEntry{'k'}}\n");

          if ( $xmlTagEntry{'v'} ne $dbTagEntry{ $xmlTagEntry{'k'}} )
          {
            print( "Tag values do not match for way XML $currXmlWayId, " .
              "database way $databaseWayId, key = $xmlTagEntry{'k'}, " .
              "XML = " . $xmlTagEntry{'v'} . ", DB = " .
              $dbTagEntry{ $xmlTagEntry{'k'} } . "\n");

            exit;
          }
          else
          {
            #print( "Data match on key $xmlTagEntry{'k'}\n");
            #print( "\tXML (UTF8): $xmlUtf8\n\tDB (UTF8): $dbUtf8\n");

          }

        }
      }
    }
    else
    {
      # Confirm database does not have tags either
      if ( exists($currentWaysData{$databaseWayId}->{'tags'}) )     
      {
        print( "XML did not have tags for way $currXmlWayId, but matching " .
          "database way $databaseWayId did!\n" );
        exit;
      }
    }

    # way_nodes 
    if ( exists($currXmlWay{'nd'}) )
    {
      my $xmlWayNodesArrayRef = $currXmlWay{'nd'};
      
      # NOTE: the database may have less nodes in the way than the XML!!!
      #
      # If the XML was not internally consistent (i.e., there is a way
      #   in the XML that contains a node reference node ID 192837, 
      #   <nd ref="192837"/>, but there is no entry for node ID 
      #   192837 inside that XML file), we will omit that node from its
      #   respective way. We need to make sure that the list of nodes
      #   in the way:
      #
      #   - Is no LONGER than the list of nodes in the XML
      #   - Every node listed in the database matches the relative order
      #       of nodes in the XML
      #   - Any nodes missing from the way are ALSO missing from the 
      #       nodes section of the database 
      #   - There are no nodes in the database way that are NOT listed in the
      #       XML

      # Make sure number of nodes in the XML is GREATER OR EQUAL TO nodes in DB way
      my $numXmlWayNodes = scalar(@{$xmlWayNodesArrayRef});
      my $numDatabaseWayNodes = scalar(keys(%{ $currentWaysData{$databaseWayId}->{'way_nodes'}}));
      #print( "\nNumber of nodes for way $currXmlWayId in XML: $numXmlWayNodes\n" .
      #  "Number of nodes in database version of way with ID $databaseWayId: " .
      #  $numDatabaseWayNodes . "\n" );
      if ( $numXmlWayNodes < $numDatabaseWayNodes )
      {
        print( "ERROR: database way $databaseWayId has MORE way nodes in it than its " .
          "XML counterpart way $currXmlWayId: ($numDatabaseWayNodes > $numXmlWayNodes)\n" );
        exit;
      }   
      # Iterate through the list, if any are missing in database version, make sure they're
      #     missing because they were missing in nodes section of database as well
      if ( $numDatabaseWayNodes < $numXmlWayNodes )
      {
        print( "INFO: XML way $currXmlWayId has more nodes than its database version $databaseWayId\n");
      }

      my $databaseWayNodeEntryIndex = 1;
      my $i; 
      for ( $i = 0; $i < $numXmlWayNodes; ++$i )
      {
        my $currXmlWayNodeId = $xmlWayNodesArrayRef->[$i];
        #print( "Way $currXmlWayId way node sequence " . ($i + 1) . ": $currXmlWayNodeId\n" );

        # Find corresponding node entry in list of database nodes
        my $dbNodeSearchIndex;
        my $foundMatch = 0;
        for ( $dbNodeSearchIndex = $databaseWayNodeEntryIndex; 
            $dbNodeSearchIndex <= $numDatabaseWayNodes;
            ++$dbNodeSearchIndex )
        {
          my $currDbWayNodeEntry = 
            $currentWaysData{$databaseWayId}->{'way_nodes'}->{$dbNodeSearchIndex};
          if ( $nodeIdMappingsXmlToDb{$currXmlWayNodeId} == $currDbWayNodeEntry )
          {
            #print( "XML waynode entry " . ($i + 1) . ", node id = $currXmlWayNodeId maps to " .
            #  "database waynode entry $dbNodeSearchIndex, node id = $currDbWayNodeEntry\n" );

            $foundMatch = 1;
            $databaseWayNodeEntryIndex = ($i + 1);
            last;
          }
        }

        if ( $foundMatch == 0 ) 
        {
          print( "Could not find XML way $currXmlWayNodeId, index = " . ($i + 1) . 
            ", node ID = $currXmlWayNodeId in database way $databaseWayId\n");
          exit;
        }

        # Confirm DB match was not at a HIGHER index than XML
        if ( $dbNodeSearchIndex > ($i + 1) )
        {
          print( "XML way $currXmlWayNodeId, node index = " . ($i + 1) .
            ", node ID = $currXmlWayNodeId at invalid index $dbNodeSearchIndex " .
            "in database way $databaseWayId\n");
        }
      }
    }
    else
    {
      #print("Found an XML way with no nodes: $currXmlWayId\n");

      # Confirm database does not have nodes for this way either
      if ( exists( $currentWaysData{$databaseWayId}->{'nd'}) )
      {
        print( "XML for way $currXmlWayId did not have nodes, but database way " .
          "$databaseWayId did!\n");
        
        exit;
      }
    }
  }

  # If we made it this far, current_ways, current_way_tags, and current_way_nodes
  #     line up 100% with XML
  print("\t\tDeep inspection of data integrity: PASS\n");
}


  


sub validateWays($$)
{
  my $osmXmlWaysRef = shift(@_);
  my $dumpLinesRef = shift(@_);

  my @dumpLines = @{$dumpLinesRef};

  my %waysData;

  my $currLine;

  # Checking table: ways
  print( "\tways, way_tags, way_nodes:\n");
  my $foundStart = 0;
  foreach $currLine (@dumpLines)
  {
    chomp($currLine);

    # UTF8 decoding for non-western character sets
    $currLine = decode_utf8($currLine);

    # Find out where ways starts
    if ( $foundStart == 0 )
    {
      if ($currLine =~ /^COPY ways \(.+\) FROM stdin;/ )
      {
        $foundStart = 1;
      }

      # Either way, can't do any more processing
      next;
    }

    # Are we at end of data?
    if ( $currLine =~ /^\\./ )
    {
      last;
    }

    #print( "ways entry: $currLine\n" );

    # Have a valid way
    my %waysEntry;

    # Break into tokens based on tab delimiter
    # Schema: way_id, changeset_id, timestamp, version, visible, redaction_id
    my @tokens = split( /\t+/, $currLine);

    #print( "Found way, ID = $tokens[0]\n");

    $waysEntry{'version'} = $tokens[3];

    # Store the entry in hash of ways
    $waysData{$tokens[0]} = \%waysEntry;
  }

  #print( 'Found ' . scalar(keys(%waysData)) . " entries in ways\n" );

  # First sanity check: make sure # of OSM ways exactly matches # of OSM API DB ways
  #print( "Number of OSM ways: " . scalar(keys(%$osmXmlWaysRef)) . "\n" );
  if ( scalar(keys(%$osmXmlWaysRef)) != scalar(keys(%waysData)) )
  {
    print('ERROR: OSM XML ways: ' . scalar(keys(%$osmXmlWaysRef)) .
      ' != OSM API DB ways: ' . scalar(keys(%waysData)) . "\n\n" );

    exit;
  }

  print( "\t\tMatching number of ways: PASS (" .
    scalar(keys(%waysData)) . ")\n" );

  # Read way_tags

  $foundStart = 0;
  foreach $currLine (@dumpLines)
  {
    chomp($currLine);

    # UTF8 decoding for non-western character sets
    $currLine = decode_utf8($currLine);

    # Find out where table data starts
    if ( $foundStart == 0 )
    {
      if ($currLine =~ /^COPY way_tags \(.+\) FROM stdin;/ )
      {
        $foundStart = 1;
      }

      # Either way, can't do any more processing
      next;
    }

    # Are we at end of data?
    if ( $currLine =~ /^\\./ )
    {
      last;
    }

    #print( "way_tags entry: $currLine\n" );

    # Have a valid way
    my %wayTagsEntry;

    # Break into tokens based on tab delimiter
    # Schema: way_id, key, value, version
    my @tokens = split( /\t+/, $currLine);

    #print( "Found way tag\n");

    $wayTagsEntry{$tokens[1]} = $tokens[2];
    #print( "\tID: $tokens[0]\n\tKey: $tokens[1]\n\tValue: $tokens[2]\n");

    # Store the entry in hash of ways
    if ( exists($waysData{ $tokens[0] }->{'tags'} ) )
    {
      $waysData{ $tokens[0] }->{'tags'}->{$tokens[1]} = $tokens[2];

      #my $key;
      #foreach $key ( keys( $waysData{ $tokens[0] }->{'tags'}) )
      #{
      # print( "\tFound tags key: $key\n" );
      #}
    }
    else
    {
      $waysData{ $tokens[0] }->{'tags'} = { $tokens[1] => $tokens[2] };
    }
  }


  # Read way_nodes
  $foundStart = 0;
  foreach $currLine (@dumpLines)
  {
    chomp($currLine);

    # UTF8 decoding for non-western character sets
    $currLine = decode_utf8($currLine);

    # Find out where table data starts
    if ( $foundStart == 0 )
    {
      if ($currLine =~ /^COPY way_nodes \(.+\) FROM stdin;/ )
      {
        $foundStart = 1;
      }

      # Either way, can't do any more processing
      next;
    }

    # Are we at end of data?
    if ( $currLine =~ /^\\./ )
    {
      last;
    }

    #print( "way_nodes entry: $currLine\n" );

    # Have valid way nodes
    my %wayNodeEntry;

    # Break into tokens based on tab delimiter
    # Schema: way_id, node_id, sequence_id
    my @tokens = split( /\t+/, $currLine);

    #print( "Found way_node\n");

    #print( "\tID: $tokens[0]\n\tSequence: $tokens[3], node ID = $tokens[1]\n");

    # Store the entry in hash of nodes in this way
    if ( exists($waysData{ $tokens[0] }->{'way_nodes'} ) )
    {
      $waysData{ $tokens[0] }->{'way_nodes'}->{$tokens[3]} = $tokens[1];

      #my $way_node;
      #foreach $way_node ( sort( {$a <=> $b} keys( %{ $currentWaysData{ $tokens[0] }->{'way_nodes'}})) )
      #{
      #  print( "\tFound node for way $tokens[0]: seq $way_node = node " .
      #    $waysData{ $tokens[0] }->{'way_nodes'}->{$way_node} . "\n");
      #}
    }
    else
    {
      $waysData{ $tokens[0] }->{'way_nodes'} = { $tokens[3] => $tokens[1] };
    }
  }

  # No need for way mapping, it's done

  # Compare each XML way to corresponding entry in ways
  my $xmlWayId;
  foreach $xmlWayId ( sort( {$a <=> $b} keys(%$osmXmlWaysRef)) )
  {
    my %xmlWay = %{ $osmXmlWaysRef->{$xmlWayId} };
    my $databaseWayId = $wayIdMappingsXmlToDb{$xmlWayId};

    # Check version, tags

    # Version -- as this is a new ingest, must be v1 in database
    if ( $waysData{$wayIdMappingsXmlToDb{$xmlWayId}}->{'version'} != 1 )
    {
      print("XML way $xmlWayId with database way ID " .
          $wayIdMappingsXmlToDb{$xmlWayId} . " is not version 1 which it should be after " .
          "being newly-inserted into a fresh database\n" );
      exit;
    }

    # Tags
    if ( exists($xmlWay{'tag'}) )
    {
      #print( "XML Tags: " . Dumper($xmlWay{'tag'}) . "\n");
      #print( "DB tags: " . Dumper($waysData{$databaseWayId}->{'tags'}) . "\n");

      my $xmlTagsArrayRef = $xmlWay{'tag'};

      # Make sure number of tags are equal
      if ( scalar( @{$xmlTagsArrayRef} ) !=
          scalar( keys(%{ $waysData{$databaseWayId}->{'tags'} })) )
      {
        print("ERROR: number of tags in XML for way $xmlWayId " .
          "does not match database way $wayIdMappingsXmlToDb{$xmlWayId}\n");
        exit;
      }

      my $currTag;

      foreach $currTag ( @{$xmlTagsArrayRef} )
      {
        my %xmlTagEntry = %{ $currTag };
        #print( "Key   : $tagEntry{'k'}\n");
        #print( "Value : $tagEntry{'v'}\n");

        my %dbTagEntry = %{ $waysData{$databaseWayId}->{'tags'} };
        if ( ! exists( $dbTagEntry{ $xmlTagEntry{'k'} } ) )
        {
          print("Could not find database version of tag " . Dumper(%xmlTagEntry) . "\n" );
          exit;
        }
        else
        {
          #print("XML tag: $xmlTagEntry{'k'} => $xmlTagEntry{'v'}\n");
          #print(" DB tag: $xmlTagEntry{'k'} => $dbTagEntry{ $xmlTagEntry{'k'}}\n");

          if ( $xmlTagEntry{'v'} ne $dbTagEntry{ $xmlTagEntry{'k'}} )
          {
            print( "Tag values do not match for way XML $xmlWayId, " .
              "database way $databaseWayId, key = $xmlTagEntry{'k'}, " .
              "XML = " . $xmlTagEntry{'v'} . ", DB = " .
              $dbTagEntry{ $xmlTagEntry{'k'} } . "\n");

            exit;
          }
          else
          {
            #print( "Data match on key $xmlTagEntry{'k'}\n");
            #print( "\tXML (UTF8): $xmlUtf8\n\tDB (UTF8): $dbUtf8\n");

          }

        }
      }
    }
    else
    {
      # Confirm database does not have tags either
      if ( exists($waysData{$databaseWayId}->{'tags'}) )
      {
        print( "XML did not have tags for way $xmlWayId, but matching " .
          "database way $databaseWayId did!\n" );
        exit;
      }
    }

    # way_nodes 
    if ( exists($xmlWay{'nd'}) )
    {
      my $xmlWayNodesArrayRef = $xmlWay{'nd'};

      # NOTE: the database may have less nodes in the way than the XML!!!
      #
      # If the XML was not internally consistent (i.e., there is a way
      #   in the XML that contains a node reference node ID 192837, 
      #   <nd ref="192837"/>, but there is no entry for node ID 
      #   192837 inside that XML file), we will omit that node from its
      #   respective way. We need to make sure that the list of nodes
      #   in the way:
      #
      #   - Is no LONGER than the list of nodes in the XML
      #   - Every node listed in the database matches the relative order
      #       of nodes in the XML
      #   - Any nodes missing from the way are ALSO missing from the 
      #       nodes section of the database 
      #   - There are no nodes in the database way that are NOT listed in the
      #       XML

      # Make sure number of nodes in the XML is GREATER OR EQUAL TO nodes in DB way
      my $numXmlWayNodes = scalar(@{$xmlWayNodesArrayRef});
      my $numDatabaseWayNodes = scalar(keys(%{ $waysData{$databaseWayId}->{'way_nodes'}}));
      #print( "\nNumber of nodes for way $xmlWayId in XML: $numXmlWayNodes\n" .
      #  "Number of nodes in database version of way with ID $databaseWayId: " .
      #  $numDatabaseWayNodes . "\n" );
      if ( $numXmlWayNodes < $numDatabaseWayNodes )
      {
        print( "ERROR: database way $databaseWayId has MORE way nodes in it than its " .
          "XML counterpart way $xmlWayId: ($numDatabaseWayNodes > $numXmlWayNodes)\n" );
        exit;
      }
      # Iterate through the list, if any are missing in database version, make sure they're
      #     missing because they were missing in nodes section of database as well
      if ( $numDatabaseWayNodes < $numXmlWayNodes )
      {
        print( "INFO: XML way $xmlWayId has more nodes than its database version $databaseWayId\n");
      }

      my $databaseWayNodeEntryIndex = 1;
      my $i;
      for ( $i = 0; $i < $numXmlWayNodes; ++$i )
      {
        my $xmlWayNodeId = $xmlWayNodesArrayRef->[$i];
        #print( "Way $xmlWayId way node sequence " . ($i + 1) . ": $xmlWayNodeId\n" );

        # Find corresponding node entry in list of database nodes
        my $dbNodeSearchIndex;
        my $foundMatch = 0;
        for ( $dbNodeSearchIndex = $databaseWayNodeEntryIndex;
            $dbNodeSearchIndex <= $numDatabaseWayNodes;
            ++$dbNodeSearchIndex )
        {
          my $currDbWayNodeEntry =
            $waysData{$databaseWayId}->{'way_nodes'}->{$dbNodeSearchIndex};
          if ( $nodeIdMappingsXmlToDb{$xmlWayNodeId} == $currDbWayNodeEntry )
          {
            #print( "XML waynode entry " . ($i + 1) . ", node id = $xmlWayNodeId maps to " .
            #  "database waynode entry $dbNodeSearchIndex, node id = $currDbWayNodeEntry\n" );

            $foundMatch = 1;
            $databaseWayNodeEntryIndex = ($i + 1);
            last;
          }
        }

        if ( $foundMatch == 0 )
        {
          print( "Could not find XML way $xmlWayNodeId, index = " . ($i + 1) .
            ", node ID = $xmlWayNodeId in database way $databaseWayId\n");
          exit;
        }

        # Confirm DB match was not at a HIGHER index than XML
        if ( $dbNodeSearchIndex > ($i + 1) )
        {
          print( "XML way $xmlWayNodeId, node index = " . ($i + 1) .
            ", node ID = $xmlWayNodeId at invalid index $dbNodeSearchIndex " .
            "in database way $databaseWayId\n");
        }
      }
    }

    else
    {
      #print("Found an XML way with no nodes: $xmlWayId\n");

      # Confirm database does not have nodes for this way either
      if ( exists( $waysData{$databaseWayId}->{'nd'}) )
      {
        print( "XML for way $xmlWayId did not have nodes, but database way " .
          "$databaseWayId did!\n");

        exit;
      }
    }
  }

  # If we made it this far, ways, way_tags, and way_nodes
  #     line up 100% with XML
  print("\t\tDeep inspection of data integrity: PASS\n");
}

sub validateCurrentRelations($$$)
{
  my $osmXmlRelationsRef = shift(@_);
  my $domRef = shift(@_);
  my $dumpLinesRef = shift(@_);

  my @dumpLines = @{$dumpLinesRef};

  my %currentRelationsData;

  my $currLine;

  # Checking table: current_relations
  print( "\tcurrent_relations, current_relation_tags, current_relation_nodes:\n");
  my $foundStart = 0;
  foreach $currLine (@dumpLines)
  {
    chomp($currLine);

    # UTF8 decoding for non-western character sets
    $currLine = decode_utf8($currLine);

    # Find out where current_relations starts
    if ( $foundStart == 0 )
    {
      if ($currLine =~ /^COPY current_relations \(.+\) FROM stdin;/ )
      {
        $foundStart = 1;
      }

      # Either way, can't do any more processing
      next;
    }

    # Are we at end of data?
    if ( $currLine =~ /^\\./ )
    {
      last;
    }

    # Run string through UTF-8 decoding before processing
    $currLine = decode_utf8($currLine);

    #print( "Current_relations entry: $currLine\n" );

    # Have a valid relation
    my %currentRelationsEntry;

    # Break into tokens based on tab delimiter
    # Schema: id, changeset_id, "timestamp", visible, version
    my @tokens = split( /\s+/, $currLine);

    #print( "Found relation, ID = $tokens[0]\n");

    $currentRelationsEntry{'version'} = $tokens[5];

    # Store the entry in hash of current_relations
    $currentRelationsData{$tokens[0]} = \%currentRelationsEntry;
  }

  #print( 'Found ' . scalar(keys(%currentRelationsData)) . " entries in current_relations\n" );

  # First sanity check: make sure # of OSM relations exactly matches # of OSM API DB relations
  #print( "Number of OSM relations: " . scalar(keys(%$osmXmlRelationsRef)) . "\n" );
  if ( scalar(keys(%$osmXmlRelationsRef)) != scalar(keys(%currentRelationsData)) )
  {
    print('ERROR: OSM XML relations: ' . scalar(keys(%$osmXmlRelationsRef)) .
        ' != OSM API DB relations: ' . scalar(keys(%currentRelationsData)) . "\n\n" );

    print( "OSM relations IDs: " . Dumper( 
          sort( { $a <=> $b} keys(%$osmXmlRelationsRef))) . "\n" );
    print( "Database relation IDs: " . Dumper( 
          sort( { $a <=> $b} keys(%currentRelationsData))) . "\n" );

    exit;
  }

  print( "\t\tMatching number of relations: PASS (" .
      scalar(keys(%currentRelationsData)) . ")\n" );

  # Read current_relation_tags

  $foundStart = 0;
  foreach $currLine (@dumpLines)
  {
    chomp($currLine);

    # UTF8 decoding for non-western character sets
    $currLine = decode_utf8($currLine);

    # Find out where table data starts
    if ( $foundStart == 0 )
    {
      if ($currLine =~ /^COPY current_relation_tags \(.+\) FROM stdin;/ )
      {
        $foundStart = 1;
      }

      # Either way, can't do any more processing
      next;
    }

    # Are we at end of data?
    if ( $currLine =~ /^\\./ )
    {
      last;
    }

    #print( "Current_relation_tags entry: $currLine\n" );

    # Have a valid relation tag entry
    my %currentRelationTagsEntry;

    # Break into tokens based on tab delimiter
    # Schema: way_id, key, value
    my @tokens = split( /\t+/, $currLine);

    #print( "Found relation tag\n");

    $currentRelationTagsEntry{$tokens[1]} = $tokens[2];
    #print( "\tID: $tokens[0]\n\tKey: $tokens[1]\n\tValue: $tokens[2]\n");

    # Store the entry in hash of current_relations
    if ( exists($currentRelationsData{ $tokens[0] }->{'tags'} ) )
    {
      $currentRelationsData{ $tokens[0] }->{'tags'}->{$tokens[1]} = $tokens[2];

      #my $key;
      #foreach $key ( keys( $currentNodesData{ $tokens[0] }->{'tags'}) )
      #{
      # print( "\tFound tags key: $key\n" );
      #}
    }
    else
    {
      $currentRelationsData{ $tokens[0] }->{'tags'} = { $tokens[1] => $tokens[2] };
    }
  }

  # Read current_relation_members
  $foundStart = 0;
  foreach $currLine (@dumpLines)
  {
    chomp($currLine);

    # UTF8 decoding for non-western character sets
    $currLine = decode_utf8($currLine);

    # Find out where table data starts
    if ( $foundStart == 0 )
    {
      if ($currLine =~ /^COPY current_relation_members \(.+\) FROM stdin;/ )
      {
        $foundStart = 1;
      }

      # Either way, can't do any more processing
      next;
    }

    # Are we at end of data?
    if ( $currLine =~ /^\\./ )
    {
      last;
    }

    #print( "Current_relation_members entry: $currLine\n" );

    # Have valid relation members
    my %currentRelationMemberEntry;

    # Break into tokens based on tab delimiter
    # Schema: relation_id, member_type, member_id, member_role, sequence_id
    my @tokens = split( /\t+/, $currLine);

    if ( scalar(@tokens) != 5 )
    {

      # Only way this could really happen is if the "role" field was blank,
      # as it's only optional one.  Shift our 4th token to the right, and fill in 4th
      # with a blank
      if ( scalar(@tokens) == 4 )
      {
        $tokens[4] = $tokens[3];
        $tokens[3] = '';
      } 
      else
      {
        print("Did not parse to correct number of tokens: $currLine");
        exit;
      }

      #print( "$currLine\ntokenized and then cleaned up to:\n" . Dumper(@tokens) );
    }



    #print( "Found current_relation_member\n");

    # Store the entry in hash of members in this relation
    my $relationMemberHashRef = {
      'member_type' => $tokens[1],
      'member_id' => $tokens[2],
      'member_role' => $tokens[3] };
    if ( exists($currentRelationsData{ $tokens[0] }->{'relation_members'}) )
    {
      $currentRelationsData{ $tokens[0] }->{'relation_members'}->{$tokens[4]} = 
        $relationMemberHashRef;
    } 
    else
    {
      $currentRelationsData{ $tokens[0] }->{'relation_members'} = 
      { $tokens[4] => $relationMemberHashRef };
    }

    #print( Dumper( $currentRelationsData{ $tokens[0] }->{'relation_members'}) );
  }

  # Now that we have mapping, go back and compare each XML relation to corresponding entry in 
  #   current_relations
  my $currXmlRelationId;
  foreach $currXmlRelationId ( sort( {$a <=> $b} keys(%$osmXmlRelationsRef)) )
  {
    my %currXmlRelation = %{ $osmXmlRelationsRef->{$currXmlRelationId} };
    my $databaseRelationId = $relationIdMappingsXmlToDb{$currXmlRelationId};

    # Check version, tags

    # Version -- as this is a new ingest, must be v1 in database
    if ( $currentRelationsData{$relationIdMappingsXmlToDb{$currXmlRelationId}}->{'version'} != 1 )
    {
      print("XML relation $currXmlRelationId with database relation ID " .
          $relationIdMappingsXmlToDb{$currXmlRelationId} . " is not version 1 which it should be after " .
          "being newly-inserted into a fresh database\n" );
      exit;
    }

    # Tags
    if ( exists($currXmlRelation{'tag'}) )
    {
      #print( "XML Tags: " . Dumper($currXmlRelation{'tag'}) . "\n");
      #print( "DB tags: " . Dumper($currentRelationsData{$databaseRelationId}->{'tags'}) . "\n");

      my $xmlTagsArrayRef = $currXmlRelation{'tag'};

      # Make sure number of tags are equal
      if ( scalar( @{$xmlTagsArrayRef} ) !=
          scalar( keys(%{ $currentRelationsData{$databaseRelationId}->{'tags'} })) )
      {
        print("ERROR: number of tags in XML for relation $currXmlRelationId " .
            "does not match database relation $databaseRelationId " .
            "(" . scalar( @{$xmlTagsArrayRef}) . " != " .
            scalar( keys(%{ $currentRelationsData{$databaseRelationId}->{'tags'} })) . "\n");

        exit;
      }


      my $currTag;

      foreach $currTag ( @{$xmlTagsArrayRef} )
      {
        my %xmlTagEntry = %{ $currTag };
        #print( "Key   : $tagEntry{'k'}\n");
        #print( "Value : $tagEntry{'v'}\n");

        my %dbTagEntry = %{ $currentRelationsData{$databaseRelationId}->{'tags'} };
        if ( ! exists( $dbTagEntry{ $xmlTagEntry{'k'} } ) )
        {
          print("ERROR: Could not find database version of tag. XML:\n" . 
            Dumper(%xmlTagEntry) . "DB: " . 
            Dumper($currentRelationsData{$databaseRelationId}->{'tags'}) );
          exit;
        }
        else
        {
          #print("XML tag: $xmlTagEntry{'k'} => $xmlTagEntry{'v'}\n");
          #print(" DB tag: $xmlTagEntry{'k'} => $dbTagEntry{ $xmlTagEntry{'k'}}\n");

          if ( $xmlTagEntry{'v'} ne $dbTagEntry{ $xmlTagEntry{'k'}} )
          {
            print( "Tag values do not match for relation XML $currXmlRelationId, " .
                "database relation $databaseRelationId, key = $xmlTagEntry{'k'}, " .
                "XML = " . $xmlTagEntry{'v'} . ", DB = " . 
                $dbTagEntry{ $xmlTagEntry{'k'} } . "\n");

            exit;
          }
          else
          {
            #print( "Data match on key $xmlTagEntry{'k'}\n");
            #print( "\tXML (UTF8): $xmlUtf8\n\tDB (UTF8): $dbUtf8\n");
          }
        }
      }
    }
    else
    {
      # Confirm database does not have tags either
      if ( exists($currentRelationsData{$databaseRelationId}->{'tags'}) )
      {
        print( "ERROR: XML did not have tags for relation $currXmlRelationId, but matching " .
            "database relation $databaseRelationId did!\n" );
        exit;
      }
    }

    # Confirm relation members
    my $xmlMembersArrayRef = $currXmlRelation{'member'};
    my $dbMembersHashRef = $currentRelationsData{$databaseRelationId}->{'relation_members'};

    # Make sure number of members matches
    if ( scalar( @{$xmlMembersArrayRef} ) == 
        scalar( keys( %{ $dbMembersHashRef } ) ) )
    {
      #print( "Number of relation members matched for relation XML ID $currXmlRelationId/" .
      #    "database ID $databaseRelationId\n" );
    }
    else
    {
      #print( "\nDid not match number of members, relation XML ID $currXmlRelationId/" .
      #    "database ID $databaseRelationId (" . scalar(@{$xmlMembersArrayRef}) . 
      #    " != " . scalar(keys(%{$dbMembersHashRef})) . ")\n" );
    }

    #print( Dumper($dbMembersHashRef) );

    my $xmlMemberNum;
    my $dbSequenceNumber = 0;
    for ( $xmlMemberNum = 0; $xmlMemberNum < scalar( @{ $xmlMembersArrayRef } ); 
        ++$xmlMemberNum )
    {
      #print( "Looking to see if database has match for XML seq num $xmlMemberNum\n");

      my $foundMatch = 0;

      my $currXmlMemberRef = $xmlMembersArrayRef->[$xmlMemberNum];

      #print("XML data that needs DB match: " . Dumper($currXmlMemberRef) );

      my $i; 
      for ( $i = $dbSequenceNumber; $i < scalar( keys(%{$dbMembersHashRef}) ); 
          ++$i)
      {
        my @dbHashRefKeys = sort( { $a <=> $b} keys(%{$dbMembersHashRef}) );
        #print( "Searching at DB seq num $dbHashRefKeys[$i]\n" );

        if ( ! exists($dbMembersHashRef->{$dbHashRefKeys[$i]}) )
        {
          print("ERROR: DB hash did not have entry $dbHashRefKeys[$i]:\n" . Dumper($dbMembersHashRef));
          exit;
        }

        my $currDbMemberHashRef = $dbMembersHashRef->{$dbHashRefKeys[$i]};

        #print( "DB data: " . Dumper($currDbMemberHashRef) );

        # If they're not even the same type, move along
        if ( lc($currXmlMemberRef->{'type'}) ne 
            lc($currDbMemberHashRef->{'member_type'}) )
        {
          #print("DB seq $dbHashRefKeys[$i] is wrong type, ignoring\n");
          next;
        }

        #print("Type match!\n");

        if ( $currXmlMemberRef->{'type'} eq lc('node') )
        {
          # If there's no ID mapping, there's nothing we can compare against
          if ( ! exists($nodeIdMappingsXmlToDb{$currXmlMemberRef->{'ref'}}) )
          {
            #print("No DB ID mapping for node $currXmlMemberRef->{'ref'}, " .
            #    "have to skip DB check\n");
            last;
          }

          #print("Checking to see if we have ID and role match on " .
          #    "XML node $currXmlMemberRef->{ref}, DB node " .
          #    "$nodeIdMappingsXmlToDb{$currXmlMemberRef->{ref}}\n" );

          if ( ($nodeIdMappingsXmlToDb{$currXmlMemberRef->{ref}} ==
                $currDbMemberHashRef->{'member_id'}) &&
              lc($currXmlMemberRef->{role}) eq
              lc($currDbMemberHashRef->{'member_role'}) )
          {
            #print("FOUND MATCH!\n");
            $foundMatch = 1;
            $dbSequenceNumber = $i; 
            last;
          }
        }
        elsif ( $currXmlMemberRef->{'type'} eq lc('way') )
        {
          # If there's no ID mapping, there's nothing we can compare against
          if ( ! exists($wayIdMappingsXmlToDb{$currXmlMemberRef->{'ref'}}) )
          {
            #print("No DB ID mapping for way $currXmlMemberRef->{'ref'}, " .
            #    "have to skip DB check\n");
            last;
          }
          #print("Checking to see if we have ID and role match on " .
          #    "XML way $currXmlMemberRef->{'ref'}, DB way " .
          #    "$wayIdMappingsXmlToDb{$currXmlMemberRef->{'ref'}}\n" );

          if ( ($wayIdMappingsXmlToDb{$currXmlMemberRef->{ref}} ==
                $currDbMemberHashRef->{'member_id'}) &&
              lc($currXmlMemberRef->{role}) eq
              lc($currDbMemberHashRef->{'member_role'}) )
          {
            #print("FOUND MATCH!\n");
            $foundMatch = 1;
            $dbSequenceNumber = $i;
            last;
          }
        }
        elsif ( $currXmlMemberRef->{'type'} eq lc('relation') )
        {
          # If there's no ID mapping, there's nothing we can compare against
          if ( ! exists($relationIdMappingsXmlToDb{$currXmlMemberRef->{'ref'}}) )
          {
            #print("No DB ID mapping for relation $currXmlMemberRef->{'ref'}, " .
            #    "have to skip DB check\n");
            last;
          }
          #print("Checking to see if we have ID and role match on " .
          #    "XML relation $currXmlMemberRef->{'ref'}, DB relation " .
          #    "$relationIdMappingsXmlToDb{$currXmlMemberRef->{'ref'}}\n" );

          if ( ($relationIdMappingsXmlToDb{$currXmlMemberRef->{ref}} ==
                $currDbMemberHashRef->{'member_id'}) &&
              lc($currXmlMemberRef->{role}) eq
              lc($currDbMemberHashRef->{'member_role'}) )
          {
            #print("FOUND MATCH!\n");
            $foundMatch = 1;
            $dbSequenceNumber = $i;
            last;
          }

        }
        else
        {
          print( "ERROR: unknown relation member type $currXmlMemberRef->{'type'}\n");
          exit;
        }
      }

      if ( $foundMatch == 0 )
      {
        #print( "DB does not contain relation member, " .
        #    "checking for unresolved reference\n" ); 

        if ( lc($currXmlMemberRef->{'type'}) eq 'node' )
        {
          #print( "Checking for unresolved node ref\n");

          if ( ! exists($domRef->{node}->{$currXmlMemberRef->{ref}}) )
          {
            #print( "XML does not contain the target node ID " .
            #    "$currXmlMemberRef->{ref}, confirmed OK unresolved reference\n");
          }
          else
          {
            print( "ERROR: not unresolved reference, just an error");
            exit;
          }
        }
        elsif( lc($currXmlMemberRef->{'type'}) eq 'way' )
        {
          #print("Checking for unresolved way ref\n");

          if ( ! exists($domRef->{way}->{$currXmlMemberRef->{ref}}) )
          {
            #print( "XML does not contain the target way ID " .
            #    "$currXmlMemberRef->{ref}, confirmed OK unresolved reference\n");
          }
          else
          {
            print( "ERROR: not unresolved reference, just an error");
            exit;
          }

        }
        elsif( lc($currXmlMemberRef->{'type'}) eq 'relation' )
        {
          #print("Checking for unresolved relation ref\n");

          if ( ! exists($domRef->{relation}->{$currXmlMemberRef->{ref}}) )
          {
            #print( "XML does not contain the target relation ID " .
            #    "$currXmlMemberRef->{ref}, confirmed OK unresolved reference\n");
          }
          else
          {
            print( "ERROR: not unresolved reference, just an error");
            exit;
          }
        }
        else
        {
          print("ERROR: Unknown relation member type $currXmlMemberRef->{'type'}\n");
          exit;
        }
      }
    }
    #print( "Done with validation for $currXmlRelationId\n");
  }

  # If we made it this far, current_relations, current_relationy_tags, and 
  #     current_relation_members line up 100% with XML
  print("\t\tDeep inspection of data integrity: PASS\n");
}

sub validateRelations($$$)
{
  my $osmXmlRelationsRef = shift(@_);
  my $domRef = shift(@_);
  my $dumpLinesRef = shift(@_);

  my @dumpLines = @{$dumpLinesRef};

  my %relationsData;

  my $currLine;

  # Checking table: relations
  print( "\trelations, relation_tags, relation_nodes:\n");
  my $foundStart = 0;
  foreach $currLine (@dumpLines)
  {
    chomp($currLine);

    # UTF8 decoding for non-western character sets
    $currLine = decode_utf8($currLine);

    # Find out where relations starts
    if ( $foundStart == 0 )
    {
      if ($currLine =~ /^COPY relations \(.+\) FROM stdin;/ )
      {
        $foundStart = 1;
      }

      # Either way, can't do any more processing
      next;
    }

    # Are we at end of data?
    if ( $currLine =~ /^\\./ )
    {
      last;
    }

    #print( "relations entry: $currLine\n" );

    # Have a valid relation
    my %relationsEntry;

    # Break into tokens based on tab delimiter
    # Schema: relation_id, changeset_id, timestamp, version, visible, redaction_id
    my @tokens = split( /\t/, $currLine);

    # Validate split
    if ( scalar(@tokens) != 6 )
    {
      print( "ERROR: $currLine did not tokenize correctly\n" );
      print( Dumper(@tokens) );
      exit;
    }

    #print( "Found relation, ID = $tokens[0]\n");

    $relationsEntry{'version'} = $tokens[3];

    # Store the entry in hash of relations
    $relationsData{$tokens[0]} = \%relationsEntry;
  }

  #print( 'Found ' . scalar(keys(%relationsData)) . " entries in current_relations\n" );

  # First sanity check: make sure # of OSM relations exactly matches # of OSM API DB relations
  #print( "Number of OSM relations: " . scalar(keys(%$osmXmlRelationsRef)) . "\n" );
  if ( scalar(keys(%$osmXmlRelationsRef)) != scalar(keys(%relationsData)) )
  {
    print('ERROR: OSM XML relations: ' . scalar(keys(%$osmXmlRelationsRef)) .
        ' != OSM API DB relations: ' . scalar(keys(%relationsData)) . "\n\n" );

    print( "OSM relations IDs: " . Dumper(
          sort( { $a <=> $b} keys(%$osmXmlRelationsRef))) . "\n" );
    print( "Database relation IDs: " . Dumper(
          sort( { $a <=> $b} keys(%relationsData))) . "\n" );

    exit;
  }

  print( "\t\tMatching number of relations: PASS (" .
      scalar(keys(%relationsData)) . ")\n" );

  # Read relation_tags
  $foundStart = 0;
  foreach $currLine (@dumpLines)
  {
    chomp($currLine);

    # UTF8 decoding for non-western character sets
    $currLine = decode_utf8($currLine);

    # Find out where table data starts
    if ( $foundStart == 0 )
    {
      if ($currLine =~ /^COPY relation_tags \(.+\) FROM stdin;/ )
      {
        $foundStart = 1;
      }

      # Either way, can't do any more processing
      next;
    }

    # Are we at end of data?
    if ( $currLine =~ /^\\./ )
    {
      last;
    }

    #print( "relation_tags entry: $currLine\n" );

    # Have a valid relation tag entry
    my %relationTagsEntry;

    # Break into tokens based on tab delimiter
    # Schema: way_id, key, value, version
    my @tokens = split( /\t/, $currLine);

    if ( scalar(@tokens) != 4 )
    {
      print("Could not parse $currLine into tokens");
      exit;
    }


    #print( "Found relation tag\n");

    $relationTagsEntry{$tokens[1]} = $tokens[2];
    #print( "\tID: $tokens[0]\n\tKey: $tokens[1]\n\tValue: $tokens[2]\n");

    # Store the entry in hash of relations
    if ( exists($relationsData{ $tokens[0] }->{'tags'} ) )
    {
      $relationsData{ $tokens[0] }->{'tags'}->{$tokens[1]} = $tokens[2];

      #my $key;
      #foreach $key ( keys( $currentNodesData{ $tokens[0] }->{'tags'}) )
      #{
      # print( "\tFound tags key: $key\n" );
      #}
    }
    else
    {
      $relationsData{ $tokens[0] }->{'tags'} = { $tokens[1] => $tokens[2] };
    }
  }

  # Read relation_members
  $foundStart = 0;
  foreach $currLine (@dumpLines)
  {
    chomp($currLine);

    # UTF8 decoding for non-western character sets
    $currLine = decode_utf8($currLine);

    # Find out where table data starts
    if ( $foundStart == 0 )
    {
      if ($currLine =~ /^COPY relation_members \(.+\) FROM stdin;/ )
      {
        $foundStart = 1;
      }

      # Either way, can't do any more processing
      next;
    }

    # Are we at end of data?
    if ( $currLine =~ /^\\./ )
    {
      last;
    }

    #print( "relation_members entry: $currLine\n" );

    # Have valid relation members
    my %relationMemberEntry;

    # Break into tokens based on tab delimiter
    # Schema: relation_id, member_type, member_id, member_role, version, sequence_id
    my @tokens = split( /\t/, $currLine);

    if ( scalar(@tokens) != 6 )
    {
      print("Did not parse to correct number of tokens: $currLine");
      exit;
    }

    #print( "Found relation_member\n");

    # Store the entry in hash of members in this relation
    my $relationMemberHashRef = {
      'member_type' => $tokens[1],
      'member_id' => $tokens[2],
      'member_role' => $tokens[3] };
    if ( exists($relationsData{ $tokens[0] }->{'relation_members'}) )
    {
      $relationsData{ $tokens[0] }->{'relation_members'}->{$tokens[5]} =
        $relationMemberHashRef;
    }
    else
    {
      $relationsData{ $tokens[0] }->{'relation_members'} =
      { $tokens[5] => $relationMemberHashRef };
    }

    #print( Dumper( $relationsData{ $tokens[0] }->{'relation_members'}) );
  }

  # Compare each XML relation to corresponding entry in relations
  my $currXmlRelationId;
  foreach $currXmlRelationId ( sort( {$a <=> $b} keys(%$osmXmlRelationsRef)) )
  {
    my %currXmlRelation = %{ $osmXmlRelationsRef->{$currXmlRelationId} };
    my $databaseRelationId = $relationIdMappingsXmlToDb{$currXmlRelationId};

    # Check version, tags

    # Version -- as this is a new ingest, must be v1 in database
    if ( $relationsData{$relationIdMappingsXmlToDb{$currXmlRelationId}}->{'version'} != 1 )
    {
      print("XML relation $currXmlRelationId with database relation ID " .
          $relationIdMappingsXmlToDb{$currXmlRelationId} . " is not version 1 which it should be after " .
          "being newly-inserted into a fresh database\n" );
      exit;
    }

    # Tags
    if ( exists($currXmlRelation{'tag'}) )
    {
      #print( "XML Tags: " . Dumper($currXmlRelation{'tag'}) . "\n");
      #print( "DB tags: " . Dumper($relationsData{$databaseRelationId}->{'tags'}) . "\n");

      my $xmlTagsArrayRef = $currXmlRelation{'tag'};

      # Make sure number of tags are equal
      if ( scalar( @{$xmlTagsArrayRef} ) !=
          scalar( keys(%{ $relationsData{$databaseRelationId}->{'tags'} })) )
      {
        print("ERROR: number of tags in XML for relation $currXmlRelationId " .
            "does not match database relation $databaseRelationId " .
            "(" . scalar( @{$xmlTagsArrayRef}) . " != " .
            scalar( keys(%{ $relationsData{$databaseRelationId}->{'tags'} })) . "\n");

        exit;
      }

      my $currTag;

      foreach $currTag ( @{$xmlTagsArrayRef} )
      {
        my %xmlTagEntry = %{ $currTag };
        #print( "Key   : $tagEntry{'k'}\n");
        #print( "Value : $tagEntry{'v'}\n");

        my %dbTagEntry = %{ $relationsData{$databaseRelationId}->{'tags'} };
        if ( ! exists( $dbTagEntry{ $xmlTagEntry{'k'} } ) )
        {
          print("ERROR: Could not find database version of tag " . Dumper(%xmlTagEntry) . "\n" );
          exit;
        }
        else
        {
          #print("XML tag: $xmlTagEntry{'k'} => $xmlTagEntry{'v'}\n");
          #print(" DB tag: $xmlTagEntry{'k'} => $dbTagEntry{ $xmlTagEntry{'k'}}\n");

          if ( $xmlTagEntry{'v'} ne $dbTagEntry{ $xmlTagEntry{'k'}} )
          {
            print( "Tag values do not match for relation XML $currXmlRelationId, " .
                "database relation $databaseRelationId, key = $xmlTagEntry{'k'}, " .
                "XML = " . $xmlTagEntry{'v'} . ", DB = " . 
                $dbTagEntry{ $xmlTagEntry{'k'} } . "\n");

            exit;
          }
          else
          {
            #print( "Data match on key $xmlTagEntry{'k'}\n");
            #print( "\tXML (UTF8): $xmlUtf8\n\tDB (UTF8): $dbUtf8\n");
          }
        }
      }
    }
    else
    {
      # Confirm database does not have tags either
      if ( exists($relationsData{$databaseRelationId}->{'tags'}) )
      {
        print( "ERROR: XML did not have tags for relation $currXmlRelationId, but matching " .
            "database relation $databaseRelationId did!\n" );
        exit;
      }
    }

    # Confirm relation members
    my $xmlMembersArrayRef = $currXmlRelation{'member'};
    my $dbMembersHashRef = $relationsData{$databaseRelationId}->{'relation_members'};

    # Make sure number of members matches
    if ( scalar( @{$xmlMembersArrayRef} ) ==
        scalar( keys( %{ $dbMembersHashRef } ) ) )
    {
      #print( "Number of relation members matched for relation XML ID $currXmlRelationId/" .
      #    "database ID $databaseRelationId\n" );
    }
    else
    {
      #print( "\nDid not match number of members, relation XML ID $currXmlRelationId/" .
      #    "database ID $databaseRelationId (" . scalar(@{$xmlMembersArrayRef}) . 
      #    " != " . scalar(keys(%{$dbMembersHashRef})) . ")\n" );
    }

    #print( Dumper($dbMembersHashRef) );

    my $xmlMemberNum;
    my $dbSequenceNumber = 0;
    for ( $xmlMemberNum = 0; $xmlMemberNum < scalar( @{ $xmlMembersArrayRef } );
        ++$xmlMemberNum )
    {
      #print( "Looking to see if database has match for XML seq num $xmlMemberNum\n");

      my $foundMatch = 0;

      my $currXmlMemberRef = $xmlMembersArrayRef->[$xmlMemberNum];

      #print("XML data that needs DB match: " . Dumper($currXmlMemberRef) );

      my $i;
      for ( $i = $dbSequenceNumber; $i < scalar( keys(%{$dbMembersHashRef}) );
          ++$i)
      {
        my @dbHashRefKeys = sort( { $a <=> $b} keys(%{$dbMembersHashRef}) );
        #print( "Searching at DB seq num $dbHashRefKeys[$i]\n" );

        if ( ! exists($dbMembersHashRef->{$dbHashRefKeys[$i]}) )
        {
          print("ERROR: DB hash did not have entry $dbHashRefKeys[$i]:\n" . Dumper($dbMembersHashRef));
          exit;
        }

        my $currDbMemberHashRef = $dbMembersHashRef->{$dbHashRefKeys[$i]};

        #print( "DB data: " . Dumper($currDbMemberHashRef) );

        # If they're not even the same type, move along
        if ( lc($currXmlMemberRef->{'type'}) ne
            lc($currDbMemberHashRef->{'member_type'}) )
        {
          #print("DB seq $dbHashRefKeys[$i] is wrong type, ignoring\n");
          next;
        }

        #print("Type match!\n");

        if ( $currXmlMemberRef->{'type'} eq lc('node') )
        {
          # If there's no ID mapping, there's nothing we can compare against
          if ( ! exists($nodeIdMappingsXmlToDb{$currXmlMemberRef->{'ref'}}) )
          {
            #print("No DB ID mapping for node $currXmlMemberRef->{'ref'}, " .
            #    "have to skip DB check\n");
            last;
          }

          #print("Checking to see if we have ID and role match on " .
          #    "XML node $currXmlMemberRef->{ref}, DB node " .
          #    "$nodeIdMappingsXmlToDb{$currXmlMemberRef->{ref}}\n" );

          if ( ($nodeIdMappingsXmlToDb{$currXmlMemberRef->{ref}} ==
                $currDbMemberHashRef->{'member_id'}) &&
              lc($currXmlMemberRef->{role}) eq
              lc($currDbMemberHashRef->{'member_role'}) )
          {
            #print("FOUND MATCH!\n");
            $foundMatch = 1;
            $dbSequenceNumber = $i;
            last;
          }
        }

        elsif ( $currXmlMemberRef->{'type'} eq lc('way') )
        {
          # If there's no ID mapping, there's nothing we can compare against
          if ( ! exists($wayIdMappingsXmlToDb{$currXmlMemberRef->{'ref'}}) )
          {
            #print("No DB ID mapping for way $currXmlMemberRef->{'ref'}, " .
            #    "have to skip DB check\n");
            last;
          }
          #print("Checking to see if we have ID and role match on " .
          #    "XML way $currXmlMemberRef->{'ref'}, DB way " .
          #    "$wayIdMappingsXmlToDb{$currXmlMemberRef->{'ref'}}\n" );

          if ( ($wayIdMappingsXmlToDb{$currXmlMemberRef->{ref}} ==
                $currDbMemberHashRef->{'member_id'}) &&
              lc($currXmlMemberRef->{role}) eq
              lc($currDbMemberHashRef->{'member_role'}) )
          {
            #print("FOUND MATCH!\n");
            $foundMatch = 1;
            $dbSequenceNumber = $i;
            last;
          }
        }
        elsif ( $currXmlMemberRef->{'type'} eq lc('relation') )
        {
          # If there's no ID mapping, there's nothing we can compare against
          if ( ! exists($relationIdMappingsXmlToDb{$currXmlMemberRef->{'ref'}}) )
          {
            #print("No DB ID mapping for relation $currXmlMemberRef->{'ref'}, " .
            #    "have to skip DB check\n");
            last;
          }
          #print("Checking to see if we have ID and role match on " .
          #    "XML relation $currXmlMemberRef->{'ref'}, DB relation " .
          #    "$relationIdMappingsXmlToDb{$currXmlMemberRef->{'ref'}}\n" );

          if ( ($relationIdMappingsXmlToDb{$currXmlMemberRef->{ref}} ==
                $currDbMemberHashRef->{'member_id'}) &&
              lc($currXmlMemberRef->{role}) eq
              lc($currDbMemberHashRef->{'member_role'}) )
          {
            #print("FOUND MATCH!\n");
            $foundMatch = 1;
            $dbSequenceNumber = $i;
            last;
          }

        }
        else
        {
          print( "ERROR: unknown relation member type $currXmlMemberRef->{'type'}\n");
          exit;
        }
      }

      if ( $foundMatch == 0 )
      {
        #print( "DB does not contain relation member, " .
        #    "checking for unresolved reference\n" ); 

        if ( lc($currXmlMemberRef->{'type'}) eq 'node' )
        {
          #print( "Checking for unresolved node ref\n");

          if ( ! exists($domRef->{node}->{$currXmlMemberRef->{ref}}) )
          {
            #print( "XML does not contain the target node ID " .
            #    "$currXmlMemberRef->{ref}, confirmed OK unresolved reference\n");
          }
          else
          {
            print( "ERROR: not unresolved reference, just an error");
            exit;
          }
        }
        elsif( lc($currXmlMemberRef->{'type'}) eq 'way' )
        {
          #print("Checking for unresolved way ref\n");

          if ( ! exists($domRef->{way}->{$currXmlMemberRef->{ref}}) )
          {
            #print( "XML does not contain the target way ID " .
            #    "$currXmlMemberRef->{ref}, confirmed OK unresolved reference\n");
          }
          else
          {
            print( "ERROR: not unresolved reference, just an error");
            exit;
          }

        }
        elsif( lc($currXmlMemberRef->{'type'}) eq 'relation' )
        {
          #print("Checking for unresolved relation ref\n");

          if ( ! exists($domRef->{relation}->{$currXmlMemberRef->{ref}}) )
          {
            #print( "XML does not contain the target relation ID " .
            #    "$currXmlMemberRef->{ref}, confirmed OK unresolved reference\n");
          }
          else
          {
            print( "ERROR: not unresolved reference, just an error");
            exit;
          }
        }
        else
        {
          print("ERROR: Unknown relation member type $currXmlMemberRef->{'type'}\n");
          exit;
        }
      }
    }
    #print( "Done with validation for $currXmlRelationId\n");
  }

  # If we made it this far, relations, relation_tags, and 
  #     relation_members line up 100% with XML
  print("\t\tDeep inspection of data integrity: PASS\n");

}

sub validateOsmXmlRelations($$$)
{
  my $osmXmlRelationsRef = shift(@_);
  my $domRef = shift(@_);
  my $dumpLinesRef = shift(@_);

  print("\nValidating relations: ways\n");

  validateCurrentRelations($osmXmlRelationsRef, $domRef, $dumpLinesRef);
  validateRelations($osmXmlRelationsRef, $domRef, $dumpLinesRef);
}

sub readXmlToDbIdMappings($$)
{
  my $xs = shift(@_);
  my $xmlToDbIdMappingFile = shift(@_);

  my $domRef = $xs->XMLin($xmlToDbIdMappingFile,
    KeyAttr => [ ],
    ForceArray => [ 'id_mapping' ]
  );

  #print Dumper( $domRef );

  my $mappingArrayRef = $domRef->{'id_mapping'};

  my @mappingArray = @{$mappingArrayRef};

  #print( 'Found ' . scalar(@mappingArray) . " ID mapping entries\n");

  my $currIdMappingEntry;
  foreach $currIdMappingEntry ( @mappingArray )
  {
    if ( lc($currIdMappingEntry->{element_type}) eq 'node' )
    {
      #print("Found mapping for node $currIdMappingEntry->{source_id} to " .
      #  "$currIdMappingEntry->{database_id}\n" );

      $nodeIdMappingsXmlToDb{$currIdMappingEntry->{source_id}} = 
        $currIdMappingEntry->{database_id};
    }
    elsif ( lc($currIdMappingEntry->{element_type}) eq 'way' )
    {
      $wayIdMappingsXmlToDb{$currIdMappingEntry->{source_id}} = 
        $currIdMappingEntry->{database_id};
    }
    elsif( lc($currIdMappingEntry->{element_type}) eq 'relation' )
    {
      $relationIdMappingsXmlToDb{$currIdMappingEntry->{source_id}} = 
        $currIdMappingEntry->{database_id};
    }
    else
    {
      print( "Could not parse mapping entry: " . Dumper($currIdMappingEntry) . "\n" );
    }
  }
}




if ( scalar(@ARGV) != 3 ) 
{
  print( "Usage: compareOsmXmlToPgsqlDump <OSM XML file> <ID mapping XML file> <PostgreSQL pg_dump output file>\n\n");

  print("ID XML mapping file is generated by setting following run-time config in Hootenanny:\n" .
    "-D services.db.writer.output.id.mappings=<xml filename to create>\n");
  exit;
}

my $osmXmlFile = $ARGV[0];
my $xmlDbIdMappingFile = $ARGV[1];
my $pgsqlDumpFile = $ARGV[2];

open(XMLFILE, "< $osmXmlFile");
my @xmlLines = <XMLFILE>;
close(XMLFILE);

open(PGDUMPFILE, "< $pgsqlDumpFile" );
my @dumpLines = <PGDUMPFILE>;
close(PGDUMPFILE);

# Concat the XML contents into one string for parsing
my $concatOsmXml = join('', @xmlLines);

print( "OSM XML file:\t\t$osmXmlFile\nPostgreSQL dump file:\t$pgsqlDumpFile\n\n");

# Create XML parser
my $xs = XML::Simple->new();

readXmlToDbIdMappings($xs, $xmlDbIdMappingFile);

my $domRef = createOsmDom($xs, $concatOsmXml);
validateOsmXmlNodes($domRef->{node}, \@dumpLines );
validateOsmXmlWays($domRef->{way}, \@dumpLines );
validateOsmXmlRelations($domRef->{relation}, $domRef, \@dumpLines);
