#!/usr/bin/perl -w

# Compare the contents of an OSM XML file to a database dump (created with pg_dump) 
# of an OSM API database after that OSM XML file has been uploaded to it
#
# NOTE: this script requires the Perl module "XML::Simple" to be installed
#
# On Ubuntu 14.04, this can be installed using the following:
#
#     sudo apt-get install libxml-simple-perl

use strict;
require XML::Simple;

use XML::Simple qw(:strict);
use Data::Dumper;

sub createOsmDom($$);
sub validateOsmXmlNodes($$);
sub validateCurrentNodes($$);
sub convertNanodegreesStringToDegrees($);

# Globals for data
my %nodesOsm;
my %nodesPgsql;
my %nodeIdMappingsXmlToDb;

sub convertNanodegreesStringToDegrees($)
{
  #my $nanodegreesString = shift(@_);
  #print( "\tInput nanodegree string: $nanodegreesString\n");

  #my $nanodegrees = ($nanodegreesString * 1.0);

  #my $degrees = ( $nanodegrees / 10000000.0 );
  #print( "\tComputed degrees: $degrees\n\n");
  #return $degrees;

  return ( shift(@_) / 10000000.0 );
}

sub createOsmDom($$)
{
  my $xs = shift(@_);
  my $xmlString = shift(@_);

  my $domRef = $xs->XMLin($xmlString, KeyAttr => { node=> 'id' }, ForceArray => [ 'node', 'tag' ] );

  return $domRef;
}

sub validateOsmXmlNodes($$)
{
  my $osmXmlNodesRef = shift(@_);
  my $dumpLinesRef = shift(@_);

  print("Validating data: nodes\n");

  validateCurrentNodes($osmXmlNodesRef, $dumpLinesRef);
}

sub validateCurrentNodes($$)
{
  my $osmXmlNodesRef = shift(@_);
  my $dumpLinesRef = shift(@_);

  my @dumpLines = @{$dumpLinesRef};

  my %currentNodesData;

  my $currLine;

  # Checking table: current_nodes
  print( "\tTable: current_nodes\n");
  my $foundStart = 0;
  foreach $currLine (@dumpLines)
  {
    chomp($currLine);

    # Find out where current_nodes starts
    if ( $foundStart == 0 ) 
    {
      if ($currLine =~ /^COPY current_nodes .+ FROM stdin;/ )
      {
        $foundStart = 1;
      }

      # Either way, can't do any more processing
      next;
    }

    # Are we at end of data?
    if ( $currLine =~ /^\\./ )
    {
      last;
    }

    #print( "Current_nodes entry: $currLine\n" );

    # Have a valid node
    my %currentNodesEntry;

    # Break into tokens based on whitespace delimiter
    # Schema: id, latitude, longitude, changeset_id, visible, "timestamp", tile, version
    my @tokens = split( /\s+/, $currLine);

    #print( "Found node, ID = $tokens[0]\n");
  
    $currentNodesEntry{'lat'} = convertNanodegreesStringToDegrees($tokens[1]);
    #print( "\tSource string: $tokens[1]\n");
    #print( "\tConverted latitude: $currentNodesEntry{'lat'}\n");

    $currentNodesEntry{'lon'} = convertNanodegreesStringToDegrees($tokens[2]);
    #print( "\tLongitude: $currentNodesEntry{'lon'}\n");

    $currentNodesEntry{'tile_num'} = $tokens[7];
    $currentNodesEntry{'version'} = $tokens[8];

    #print( "\tCoords (lat/lon): $currentNodesEntry{'lat'}, $currentNodesEntry{'lon'}\n");
    #print( "\tTile: $currentNodesEntry{'tile_num'}\n");
    #print( "\tVersion: $currentNodesEntry{'version'}\n");

    # Store the entry in hash of current_nodes
    $currentNodesData{$tokens[0]} = \%currentNodesEntry;
  }

  #print( 'Found ' . scalar(keys(%currentNodesData)) . " entries in current_nodes\n" );

  # Read current_node_tags

  $foundStart = 0;
  foreach $currLine (@dumpLines)
  {
    chomp($currLine);

    # Find out where table data starts
    if ( $foundStart == 0 )
    {
      if ($currLine =~ /^COPY current_node_tags .+ FROM stdin;/ )
      {
        $foundStart = 1;
      }

      # Either way, can't do any more processing
      next;
    }

    # Are we at end of data?
    if ( $currLine =~ /^\\./ )
    {
      last;
    }

    #print( "Current_node_tags entry: $currLine\n" );

    # Have a valid node
    my %currentNodeTagsEntry;

    # Break into tokens based on tab delimiter
    # Schema: node_id, key, value
    my @tokens = split( /\t+/, $currLine);

    #print( "Found node tag\n");

    $currentNodeTagsEntry{$tokens[1]} = $tokens[2];
    #print( "\tID: $tokens[0]\n\tKey: $tokens[1]\n\tValue: $tokens[2]\n");

    # Store the entry in hash of current_nodes
    if ( exists($currentNodesData{ $tokens[0] }->{'tags'} ) )
    {
      $currentNodesData{ $tokens[0] }->{'tags'}->{$tokens[1]} = $tokens[2];

      #my $key;
      #foreach $key ( keys( $currentNodesData{ $tokens[0] }->{'tags'}) )
      #{
      # print( "\tFound tags key: $key\n" );
      #}
    }
    else
    {
      $currentNodesData{ $tokens[0] }->{'tags'} = { $tokens[1] => $tokens[2] };
    }
  }

  # First sanity check: make sure # of OSM current_nodes exactly matches # of OSM API DB current_nodes
  #print( "Number of OSM nodes: " . scalar(keys(%$osmXmlNodesRef)) . "\n" );
  if ( scalar(keys(%$osmXmlNodesRef)) != scalar(keys(%currentNodesData)) )
  {
    print('ERROR: OSM XML nodes: ' . scalar(keys(%$osmXmlNodesRef)) .
      ' != OSM API DB nodes: ' . scalar(keys(%currentNodesData)) . "\n\n" );

    exit;
  }
  
  print( "\t\tNumber OSM XML nodes == \"current_node\" entries (" . 
    scalar(keys(%currentNodesData)) . ")\n");

  # Now let's create mapping for Postgres Node ID -> OSM node ID.  the OSM XML node IDs were added in 
  #   ascending node ID order, so if we iterate over OSM API node IDs in ascending, we have a guaranteed mapping

  my @sortedDbNodeIds = sort( {$a <=> $b} keys(%currentNodesData));
  my $currXmlNodeId;
  my $i = 0;
  foreach $currXmlNodeId ( sort( {$a <=> $b} keys(%$osmXmlNodesRef)) )
  {
    $nodeIdMappingsXmlToDb{$currXmlNodeId} = $sortedDbNodeIds[$i];

    #print("XML node ID $currXmlNodeId maps to DB node ID $sortedDbNodeIds[$i]\n");

    $i++;
  }

  # Now that we have mapping, go back and compare each XML node to corresponding entry in current_nodes
  foreach $currXmlNodeId ( sort( {$a <=> $b} keys(%$osmXmlNodesRef)) )
  {
    my %currXmlNode = %{ $osmXmlNodesRef->{$currXmlNodeId} };
    my $databaseNodeId = $nodeIdMappingsXmlToDb{$currXmlNodeId};

    # Compare lat, lon, version, tags

    if ( $currXmlNode{'lat'} ne $currentNodesData{$nodeIdMappingsXmlToDb{$currXmlNodeId}}->{'lat'} )
    {
      print( "ERROR: XML node $currXmlNodeId latitude $currXmlNode{'lat'} != " .
        "DB node $nodeIdMappingsXmlToDb{$currXmlNodeId} lat " . 
        $currentNodesData{$nodeIdMappingsXmlToDb{$currXmlNodeId}}->{'lat'} . "\n\n" );
      exit;
    }
  
    if ( $currXmlNode{'lon'} ne $currentNodesData{$nodeIdMappingsXmlToDb{$currXmlNodeId}}->{'lon'} )
    {
      print( "ERROR: XML node $currXmlNodeId longitude $currXmlNode{'lon'} != " .
        "DB node $nodeIdMappingsXmlToDb{$currXmlNodeId} lon " .
        $currentNodesData{$nodeIdMappingsXmlToDb{$currXmlNodeId}}->{'lon'} . "\n\n" );
      exit;
    }

    # Version -- as this is a new ingest, must be v1 in database
    if ( $currentNodesData{$nodeIdMappingsXmlToDb{$currXmlNodeId}}->{'version'} != 1 )
    {
      print ("XML node $currXmlNodeId with database node ID " .
          $nodeIdMappingsXmlToDb{$currXmlNodeId} . " is not version 1 which it should be after " .
          "being newly-inserted into a fresh database\n" );
      exit;
    }

    # Tags
    if ( exists($currXmlNode{'tag'}) )
    {
      print( "XML Tags: " . Dumper($currXmlNode{'tag'}) . "\n");
      print( "DB tags: " . Dumper($currentNodesData{$databaseNodeId}->{'tags'}) . "\n");

    }
  }

  
  
}


if ( scalar(@ARGV) != 2 ) 
{
  print( "Usage: compareOsmXmlToPgsqlDump <OSM XML file> <PostgreSQL pg_dump output file>\n\n");
  exit;
}

my $osmXmlFile = $ARGV[0];
my $pgsqlDumpFile = $ARGV[1];

open(XMLFILE, "< $osmXmlFile");
my @xmlLines = <XMLFILE>;
close(XMLFILE);

open(PGDUMPFILE, "< $pgsqlDumpFile" );
my @dumpLines = <PGDUMPFILE>;
close(PGDUMPFILE);

# Concat the XML contents into one string for parsing
my $concatOsmXml = join('', @xmlLines);

print( "OSM XML file:\t\t$osmXmlFile\nPostgreSQL dump file:\t$pgsqlDumpFile\n\n");

# Create XML parser
my $xs = XML::Simple->new();

my $domRef = createOsmDom($xs, $concatOsmXml);
validateOsmXmlNodes($domRef->{node}, \@dumpLines );

